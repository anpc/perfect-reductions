%\def\draft{1} % for draft version, set draft = 1
%\def\fullV{0}
%&pdflatex
%\def\IsDraft{} % set for draft version
%\def\IsSubmission{} % set for submission version
\def\IsLLNCS{} % set for draft version
\def\IsAnon{} % set for an anonymous version
%\def\IsCR{} % set for camera ready version
%\def\IsFV{} % set for full-version

\ifdefined\IsLLNCS
\documentclass{llncs}
\usepackage{amsfonts,amsmath,amssymb,boxedminipage,color,url,nccmath}
\pagestyle{plain}
\else
\documentclass[11pt]{article}
\usepackage{amsfonts,amsmath,amssymb,amsthm,boxedminipage,color,url,fullpage,nccmath}
\fi

%\def\IsDVI{} % set to resolve conflict with hyperref when using DVI viewer
 \ifdefined\IsDVI
 \usepackage[hypertex,pdfstartview=FitH,colorlinks,linkcolor=blue,filecolor=blue,citecolor=blue,urlcolor=blue]{hyperref} % blue linkss
 \else
\usepackage[pdfstartview=FitH,colorlinks,linkcolor=blue,filecolor=blue,citecolor=blue,urlcolor=blue]{hyperref} % blue linkss
\fi

\usepackage{enumerate,paralist}
% \usepackage[labelfont=bf]{caption}

\usepackage{lmodern}% to remove LaTeX font warnings (Using lmodern removes this restriction by allowing font sizes at arbitrary sizes)

%\usepackage[bottom]{footmisc} % to make the footnote stay at the bottom of the page...
\interfootnotelinepenalty=500
\usepackage{float}
\usepackage{aliascnt}
\usepackage[numbers]{natbib} % \citet{foo} -> Foo et al. [5]

\usepackage{cleveref}
\usepackage{xspace}
\usepackage{xstring}

%\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{complexity}

%% Sets page size and margins
%\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% \usepackage{amsmath}
% \usepackage{amssymb}
% \usepackage{amsthm}
% \usepackage{graphicx}
% \usepackage[colorinlistoftodos]{todonotes}
%\usepackage[colorlinks=true, allcolors=blue]{hyperref}
%\usepackage{enumitem}  
%\setitemize{leftmargin=*, align=left}

\input{macros}
 
\newcommand{\PiC}{\Pi^{comb}_f} 
%\usepackage{xcolor}
%\newcommand\todo[1]{\textcolor{red}{#1}}

% \newtheorem{definition}{Definition}[section]
% \newtheorem{theorem}{Theorem}[section]
% \newtheorem{lemma}[theorem]{Lemma}
% \newtheorem{proposition}[theorem]{Proposition}
% \newtheorem{corollary}[theorem]{Corollary}
% \newtheorem{conjecture}[theorem]{Conjecture}   
% \newtheorem{claim}[theorem]{Claim}
% \newtheorem{remark}{Remark}
% \newtheorem{observation}{Observation}
% \newtheorem{fact}{Fact}
% \newtheorem{construction}{Construction}
\newcommand{\bnote}[1]{\authnote{Bar}{#1}}
\newcommand{\anote}[1]{\authnote{Anat}{#1}}
\newcommand{\Bnote}[1]{\authnote{Bar}{#1}}
\newcommand{\Anote}[1]{\authnote{Anat}{#1}}
\newcommand{\enote}[1]{\authnote{Eran}{#1}}


\ifdefined\IsDraft
    \newcommand{\echng}[1]{{{\bf Eran's change:} \color{blue} #1}}
\else
    \newcommand{\echng}[1]{#1}    
\fi 

\ifdefined\IsDraft
	\newcommand{\achng}[1]{{{\bf Anat's change:} \color{blue} #1}}
\else
    \newcommand{\achng}[1]{#1}
\fi    

\ifdefined\IsDraft
    \newcommand{\edel}[1]{{\color{red} [Eran's deletion #1]}}
\else
    \newcommand{\edel}[1]{}
\fi 

\newcommand{\OT}{\operatorname{OT}}
\newcommand{\OTfunc}{\mathcal{OT}}
\newcommand{\OThybrid}{\OTfunc\mbox{-}\text{hybrid}}
\newcommand{\OTHybrid}{\OTfunc\mbox{-}\text{Hybrid}}
\newcommand{\COT}{\operatorname{COT}}
% \newcommand{\bOT}[2]{#1\text{-out-of-}#2\text{ bit-}\OT}
% \newcommand{\TO}[2]{#1\text{-out-of-}#2\text{ bit-}\operatorname{TO}}
% \newcommand{\sOT}[3]{#1\text{-out-of-}#2~#3\text{-string-}\OT}
\newcommand{\bOT}[2]{\binom{#2}{#1}\text{-bit-OT}}
\newcommand{\TO}[2]{\binom{#2}{#1}\text{-bit-TO}}
\newcommand{\sOT}[3]{\binom{#2}{#1}\text{-}#3\text{-string-OT}}

\newcommand{\rampOT}{\operatorname{ROT}}
\newcommand{\ROT}{\operatorname{ROT}}
\newcommand{\stb}{\operatorname{BCS}}
%\newcommand{\int}{\operatorname{int}}

\newcommand{\support}{\mathrm{support}}

\newcommand{\field}{\mathbb{F}}

\renewcommand{\F}{\mathbb{F}}
% \newcommand{\Z}{\mathbb{Z}}
% \newcommand{\R}{\mathbb{R}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\T}{\mathcal{T}}
\renewcommand{\B}{\mathcal{B}}
%\renewcommand{\Z}{\mathcal{Z}}
\renewcommand{\Z}{\set{0,\ldots,k-1}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\W}{\mathcal{W}}

\newcommand{\affine}[1]{\normalfont{\mathbf{aff}}\of{#1}}
\newcommand{\aff}[1]{\affine{#1}}
\newcommand{\CH}[1]{\normalfont{\mathbf{conv}\of{#1}}}
\newcommand{\INT}{\Pi_{\operatorname{int}}}

\newcommand{\p}{\myvec{p}}
\renewcommand{\q}{\myvec{q}}
\renewcommand{\v}{\myvec{v}}
\renewcommand{\u}{\myvec{u}}
\renewcommand{\b}{\myvec{b}}
\newcommand{\m}{\myvec{m}}
\renewcommand{\a}{\myvec{a}}
\renewcommand{\c}{\myvec{c}}
\newcommand{\x}{\myvec{x}}
\newcommand{\y}{\myvec{y}}
\newcommand{\errvec}{\myvec{err}}
\newcommand{\errval}{\operatorname{err}}
\newcommand{\zeros}{\normalfont{\textbf{0}}}
\newcommand{\ones}{\normalfont{\textbf{1}}}

\newcommand{\norm}[2]{\left|\left|#1\right|\right|_{#2}}

\newcommand{\aux}{\mathsf{aux}}
\newcommand{\HYBRID}{\operatorname{HYBRID}}
\newcommand{\IDEAL}{\operatorname{IDEAL}}
\newcommand{\ID}{\operatorname{IV}}
\newcommand{\Out}{\operatorname{Out}}
\newcommand{\View}{\operatorname{View}}

\newcommand{\srvr}{\alpha}
\newcommand{\clnt}{\beta}
\newcommand{\local}{\varphi}

\newcommand{\CC}{\operatorname{CC}}

\newcommand{\IKOPS}{\operatorname{IKOPS}}

\renewcommand{\SD}{\operatorname*{SD}}

\renewcommand{\det}[1]{\operatorname{det}\of{#1}}

\renewcommand{\Sc}{\mathsf{S}}
\newcommand{\Cc}{\mathsf{C}}

\renewcommand{\Enc}{\mathsf{Enc}}
\renewcommand{\Dec}{\mathsf{Dec}}

\newcommand{\VC}{\mathsf{VC}}


\title{On Perfectly Secure 2PC in the OT-Hybrid Model}

\ifdefined\IsAnon
    \author{}
    \date{}
    \LLNCS{ \institute{}}
\else

    \ifdefined\IsLLNCS
        \author{Anat Paskin-Cherniavsky\
        \and Bar Alon}
        \institute{Department of Computer Science, Ariel University\\ \email{anatpc@ariel.ac.il, alonbar08@gmail.com}}
    \else
        \author{Anat Paskin-Cherniavsky\thanks{Department of Computer Science, Ariel University. E-mail: \texttt{anatpc@ariel.ac.il}.}
        \and Bar Alon\thanks{Department of Computer Science, Ariel University. E-mail: \texttt{alonbar08@gmail.com}.}}
     \fi
\fi

\begin{document}
\sloppy
\maketitle
\ifdefined\IsLLNCS
\pagestyle{plain}
\else\fi

\begin{abstract}
We initiate the systematic study of perfect reductions in secure computation.\bnote{Do we really initiate?} In addition to the obvious theoretical appeal of the question towards better understanding secure computation, perfect, as opposed to statistical reductions, may be useful for designing secure multiparty protocols with high concrete efficiency, achieved by eliminating the dependence on a security parameter.

Our focus is on two-party computation (2PC) OT-hybrid model. Specifically, we focus on the client-server model, where only one party -- the client -- receives an output. In this model, \citeauthor{IKOPS11} (EUROCRYPT 2011) showed that when the parties have access to many parallel ideal computations of OT, every 2PC functionality, can be computed using a \emph{single round} efficiently. However, their work \enote{better say -- their construction -- their work} only achieves statistical security, namely, it is allowed to have some error in security. This leaves open the natural question as to which client-server functionalities can be computed with perfect security in the OT-hybrid model, and what is the round complexity of such computation. So far, only a handful of functionalities were known to have such protocols.\enote{Suggesting: This leaves open the natural question as to which client-server functionalities can be computed with perfect security in the OT-hybrid model, and what is the round complexity of such computation. }
% It is a known fact that in the plain model, 2PC is impossible even for simple functions \cite{CK89,Cleve86}. Nonetheless, in the seminal work~\citet{GHKL08}, and later followed by \cite{Ash14,makriyannis2014classification,asharov2015complete}, it was discovered that in the $\OThybrid$ model, most of the two-party functionalities can be evaluated with full security by efficient protocols. However, these general protocols have high round complexity.

\enote{maybe start with: In this work, we...}
In this work, we prove that most client-server functions $f:\X\times \Y\mapsto \{0,1\}$, where the server's domain $\X$ is larger than the client's domain $\Y$, have a perfect reduction to OT. 
% In fact, a $\big(1-\operatorname{exp}\of{-|\Y|}\big)$-fraction of the functions are perfectly reducible to OT. 
(For example, $1-1.6\cdot10^{-6}>0.99999$ fraction of the client-server functions with domain sizes $31\times30$ are computable with full-security).
Furthermore, our reduction is 1-round using an oracle to secure evaluation of many parallel invocations of $\bOT12$ (as done by \citeauthor{IKOPS11}), where the number of invocations is independent of the server's domain and is polynomial in the client's domain. Our criterion is (almost) the same as \echng{that of} \citeauthor{Ash14}[TCC 2014] -- all functions that are \emph{full-dimensional} are computable with full-security. Our result also extends to randomized non-Boolean functions $f: \X\times\Y\mapsto\Z$ 
%a $\big(1-\operatorname{exp}\left(-(k-1)\cdot|\Y|\right)\big)$-fraction of the functions
satisfying $|\X|>(k-1)\cdot|\Y|$.
%are perfectly reducible to OT in 1 round. 

% Our work leaves open the question of whether all finite client-server functionalities are perfectly reducible to OT (not necessarily in one round). Another open question is whether 2PC functionalities that do have perfectly secure protocols in the OT hybrid model differ in round complexity, as is the case for statistical protocols.\bnote{Seems redundant}

%We initiate the study of perfect (rather than merely statistical or computational) reductions among cryptographic primitives.% For simplicity, we focus on finite functionalities.

%In addition to the obvious theoretical appeal of the question towards better understanding secure computation, perfect, as opposed to statistical reductions may be useful for designing Multiparty protocols with high concrete efficiency, achieved by eliminating the dependence on a security parameter.

% $\bOT{1}{2}$ (dubbed OT) was shown to be complete for statistically secure 2PC for all functionalities \cite{Killian88,IPS08}. Existing protocols in the $\OThybrid$ model only offer statistically secure-with-abort, yet efficient, protocols. Furthermore, they requiring no further computational assumptions. In general, the notion of fairness can not be guaranteed, and only security with abort is achievable \cite{Cleve86}. If the protocol is not required to be efficient in the security parameter $\kappa$, then all 2PC functionalities can be securely evaluated \cite{GK10} with statistical security in the $\OThybrid$ model.

% As opposed to the statistical setting, it is not known whether OT is complete for perfectly secure 2PC. Furthermore, only a few examples of functionalities that have such protocols are known: we are only aware of string-OT and TO (OT with reversed roles) as perfectly reducible to OT.
% On the negative side, a large class is known, as implied by the fairness literature. By definition, functionalities not securely computable with fairness require super-polynomial in $\kappa$ 
% computational (and round) complexity to evaluate with error $\negl(\kappa)$ in the $\OThybrid$ model. 
% This implies that these functionalities not computable with fairness are also not computable with perfect security (in the $\OThybrid$ model). For symmetric Boolean functionalities, this class been fully characterized \cite{asharov2015complete}.

% Back to the statistical world, quite surprisingly \cite{IKOPS11} demonstrate that all client-server functionalities can be efficiently reduced to OT with statistical full security (no abort) in only one round.

% Motivated by this relative ``ease'' of client-server functionalities for statistically secure 2PC in the $\OThybrid$ model, we study perfect reductions to OT for this class of functions.
% We prove that for most client-server functions of the form $f: X\times Y\mapsto \{0,1\}$, where server domain size $|Y|$ is larger than client domain size $|X|$, have a perfect reduction to OT.
% More precisely, a $g(|X|,|Y|)=\Omega(1)$-fraction of functions are perfectly reducible to OT. This fraction grows roughly as $1-exp(|X|-|Y|)$.
% Furthermore, our reduction is 1-round using an oracle to secure evaluation of ${\OT}^{\ell}$ (as in \cite{IKOPS11}). As an example, this class contains $\bOT25$.
% More generally, for $f: X\times Y\mapsto Z$, $\Omega(1)$ of the functions with $|Y|>|X|(|Z|-1)$ are perfectly reducible to OT in 1 round. 

% Our work leaves open the question of whether all finite client-server functionalities are perfectly reducible to OT (not necessarily in one round). 
% Another open question is whether 2PC functionalities that do have perfectly secure protocols in the OT hybrid model differ in round complexity, as is the case for statistical protocols.

%\keywords{two-party computation · Oblivious Transfer · }
\end{abstract}

\section{Introduction}\label{intro}
In the setting of \echng{secure two}-party computation (2PC), the goal is to allow \echng{two} mutually distrustful parties to compute some function of their private inputs. \echng{The computation should preserve} some security properties, even in the face of adversarial behavior by one of the parties. The two most common types of adversaries are \emph{malicious} adversaries (which may instruct the corrupted \echng{party} to deviate from the prescribed protocol in an \echng{arbitrary} way), and \emph{semi-honest} adversaries (which must follow the instructions of the protocol, but may try to infer additional information based on the view of the corrupted party).

\enote{Don't write 2 in the text. Write two, I did so above.}

Oblivious transfer (OT) is a \echng{two}-party functionality, fundamental
to secure multiparty computation, that was first introduced by \citet{rabinOT} and \citet{evenOT1985randomized}. In the setting \echng{of} $\bOT12$, there is a receiver holding a bit
$b\in\zo$, and a sender holding two bit-messages $a_0,a_1\in\zo$. At the end of the interaction, the receiver
learns $a_b$ and nothing else, and the sender learns nothing. It turns out that OT can be used in \echng{the} construction of protocols, both in 2PC and multiparty computation (MPC) with various security guarantees against malicious adversaries \cite{Yao82,Killian88OT,GMW87,BMR90}. Moreover, giving to the parties access to an ideal process that computes OT securely, is potentially useful. Constructing protocols in this model, called the OT-hybrid model, could be used for optimizing the complexity of real-world, computationally secure protocols for several reasons.\deleted{\echng{ constructing protocols in the OT-hybrid model is} potentially useful for optimizing the complexity of real-world, computationally secure protocols for several reasons.} \echng{First, using the OT-precomputation paradigm of \citet{beaver1995precomputing}, the heavy computation of OT can many times be pushed back to} an off-line \echng{phase}. This off-line  phase is performed before the actual inputs \echng{for the computation (and possibly even the function to be computed) are known. Later, as the actual computation takes place, the precomputed OTs are} very cheaply converted into actual OT interactions. Furthermore, \echng{the OT-extension paradigm of  \cite{beaverOTextension} offers a way to  efficiently implement many OTs using a relatively small number of base OTs. This can be done} using only symmetric-key primitives (\eg one-way functions, pseudorandom generators). Furthermore, it can also be used to implement $\sOT{1}{2}{s}$ using a sub-linear (in the security parameter) number of calls to $\bOT{1}{2}$ and some additional sub-linear work, assuming a strong variant of PRG~\cite{IKOS08}. Additionally, there is a variety of computational assumptions that are sufficient to realize OT \cite{peikert2008framework}, or even with unconditional security under physical assumptions \cite{khurana2016secure}. \bnote{Talk with Anat about citations}

\deleted{In the 2PC settings, \citet{CK89} showed that in the plain model, even for simple functions such as AND and OR, fully secure computation is impossible against semi-honest adversaries, even when the parties are unbounded. Furthermore,} Although the OT-hybrid model has many practical uses, there are some limitations to it. In the 2PC settings, \citet{Cleve86} showed that the functionality of Coin-Tossing, where the parties output the same random bit, is impossible to compute full-security\deleted{, even though it can be easily computed with security against semi-honest adversaries}. In spite of that, in the seminal work~\citet{GHKL08}, and later followed by~\cite{Ash14,makriyannis2014classification,daza2017designingfull,asharov2015complete}, it was discovered that in the OT-hybrid model\deleted{ under the assumption that protocols for securely computing OT exists}, most two-party functionalities can be evaluated with full security by efficient protocols. In particular,~\cite{asharov2015complete} completes the characterization of symmetric Boolean functions (where both parties receive the same output).\deleted{In other words, in the OT-hybrid model, where the parties have access to (many parallel) ideal processes that computes OT securely, most of the two-party functionalities can be evaluated with full-security.} However, all known general protocols for such functionalities have round complexity that is super-logarithmic in the security parameter. Moreover, this was proven to be necessary for functions with embedded XOR \cite{GHKL08}.
 
This raises a natural question, as to what is the optimal round complexity for families of functions that do not have an embedded XOR. An interesting special case of these functionalities, are client-server functionalities, where only one party -- the client -- receives an output. 
% A secure and efficient computation for this class of functions is useful for many interesting applications, both in theory and in practice. 
In addition to the OT functionality mentioned earlier, client-server functionalities include many other examples. Securely computing some of theses functionalities could be useful for many interesting applications, both in theory and in practice. For example, consider a recommendation system of say, movies. Then using secure computation, a user could receive a recommendation from a server, where the recommendation was not biased towards a certain movie (by more than what the recommendation function allows). Furthermore, the server will not know what types of movies the user likes to watch.
% For example, consider a user Bob on a dating website who wants to know how much of a good match is Alice -- another user. Suppose that Alice is not logged into the website, so the server takes her place in the computation. The results should tell Bob whether or not they are a match, and whether he should message Alice. Then using secure computation, Bob will be able to check if they are a match privately, and so that the server will not harm the result (\eg forcing a match when there is non).
% Another example, is function evaluation on a database. Suppose that a server holds some database with sensitive information, and that a curator (the client) wishes to evaluate some function on the database, so that the server neither learns what the curator computed, nor will it be able to affect the outcome, and the curator will not be able to learn any additional information on the database other than what the output provides (If the function can be computed with \emph{differential privacy}, then the privacy of the database is also preserved by the output). 
% Additionally, all known two-party protocols for computing \emph{Private Set Intersection} also falls into this category (assuming that the size of the client's set was already known to the server), where only one of the parties learns the intersection.

For client-server functionalities, \citet{IKOPS11} showed that in the OT-hybrid model, every such two-party functionality can be computed using a \emph{single round}. Furthermore, the protocol's computational and communication complexity are efficient. However, their construction achieves only \emph{statistical security}, namely, it is allowed to have some error in security. 

For the case of perfect security in this setting much less is known. Given access to (many parallel) ideal computations for $\bOT12$, \citet{BCS96} showed how to compute the functionality $\sOT{1}{n}{s}$, and \citet{WolfW06} showed how to compute $\TO{1}{2}$, which is the same as $\bOT{1}{2}$ where the roles of the parties are reversed. Furthermore, the former protocol has a single round, in which the parties invoke the OT, and with no additional bits to be sent over the channel between the parties. The latter protocol requires an additional bit to be sent by the server. \citet{IKMOP13} studied perfectly secure MPC in the correlated randomness model. They showed that any multiparty client-server functionality can be computed with perfect security, in a hybrid model of a two-party randomized function with no inputs. Here the hybrid model depends on the function to be computed by the parties.

% On the positive side, we are aware of only a handful of perfect reductions to $\bOT{1}{2}$. One is from string-OT~\cite{BCS96}, and one from $\TO{1}{2}$~\cite{WolfW06}, which is the same as $\bOT{1}{2}$ where the roles of the parties are reversed. The first one sends no bits over the point to point channel, and only uses to ${\bOT{1}{2}}^l$ oracle, while the latter only requires only a single bit of additional communication over the channel.
% On the negative side, 2PC functionalities requiring $\omega_k(1)$ rounds mentioned above are not perfectly computable. 

Thus, the state of affairs is that most two-party client-server functionalities remain unclassified as to perfect security in the OT-hybrid model. In this work we address the following natural question.
\begin{quote}
Which client-server functionalities can be computed with \emph{perfect security} in the OT-hybrid model, and what is the round complexity of such computation. 
\end{quote}
The question has an obvious theoretical appeal to it, and understanding it could help us gain a better understanding of general secure computation. In addition, perfect security may be useful for designing multiparty protocols with high concrete efficiency, achieved by eliminating the dependency on a security parameter.

%For $\bOT{k}{n}$ or $\sOT{k}{n}{h}$, it will be convenient to denote the input domain $X$ as $X=\{c\in\{0,1,\bot\}^n|c\text{ contains exactly }k\text{ non-}\bot\text{ values}\}$. 

\subsection{Our Results}\label{sec:results}
Our main result, is that if the parties have access to many parallel ideal computations of $\bOT12$, most client-server functionalities, where the server's domain is larger than the client's domain, can be computed with perfect full-security in a single round. Interestingly, the set of functions that we are able to compute was previously identified by \citet{Ash14} in the context of fairness in two-party computation, naming these functions as \emph{full-dimensional}. 

Let $f : \X \times \Y \mapsto \zo$ be a function, where the server's domain size $|\X|$ is larger than the client's domain size $|\Y|$. We consider the geometric representation of $f$ as $|\X|$ points over $\R^{|\Y|}$, where the $j$-th coordinate of the $i$-th
point is simply $f(x_i, y_j)$. We then consider the \emph{convex polytope}\footnote{A polytope is a generalization in any number of dimensions of the two-dimensional polygon and the three-dimensional polyhedron.} defined by these points. The function is called \emph{full-dimensional} if the dimension of the polytope is exactly $|\Y|$, \eg a triangle in the plane.  We prove the following theorem:

\begin{theorem}[Informal]\label{thm:introMain}
	Let $f:\X \times \Y \mapsto \zo$ be a client-server functionality. If $f$ is full-dimensional, then it can be computed with perfect full-security in the OT-hybrid model in a single round. 
    
    Furthermore, if $f$ is deterministic, then the number of bits sent to the OT by the parties is $\tilde{O}\of{\poly\of{|\Y|}}$.\TODO{Verify.}
\end{theorem}

%In fact, we generalize the above theorem, and we give a similar criteria for randomized non-Boolean functions.
Theorem~\ref{thm:introMain} identifies a set of client-server functionalities that are computable with perfect full-security. It does not yield a full characterization of such functions, however, for the case of Boolean functions, we are able to show that the protocol suggested in the proof of Theorem~\ref{thm:introMain} computes \emph{only} full-dimensional functions.

% For deterministic functions we manage to give a concrete bound on the communication complexity of the protocol that depends only on the dimension of the function. For randomized functions, we cannot give such a bound, since it may depend on function.  

\subsection{Our Techniques}
In our construction, we make use of a perfect randomized encoding (PRE). A PRE $\hat{f}$  of a function $f$ \cite{AIK04} is a randomized function, such that for every input $x$ and a uniformly random choice of the randomness $r$, it is possible to decode $\hat{f}(x;r)$ and compute $f(x)$ with no error. In addition, the output distribution of $\hat{f}$ on input $x$ reveals no information about $x$ except what follows from $f(x)$. The PRE is said to be decomposable, if it can be written as $\hat{f}=\vect{\hat{f}_1,\ldots,\hat{f}_n}$. Here, each $\hat{f}_i$ can be written as one of two vectors that depends on the $i$-th bit of $x$, \ie we can write it as $\v_{i,x_i}$, where $(\v_{i,0},\v_{i,1})$ depends on the randomness $r$.
% forms a “randomized encoding” of $f(x)$, from which $f(x)$ can be decoded. That is, if $f(x) \ne f(x')$ then the random variables
% $\hat{f}(x;r)$ and $\hat{f}(x';r')$ induced by a uniform choice of $r$ and $r'$, should have disjoint supports.

% $$\hat{f}\of{x;r}=\vect{\hat{f}_0\of{r},\hat{f}_1\of{x_1;r},\ldots,\hat{f}_n\of{x_n;r}}.$$


Our starting point is the protocol of \citet{IKOPS11}, which will be dubbed the IKOPS protocol. This is a  single round protocol in the OT-hybrid model that achieves statistical security. It allows the parties to compute a ``certified OT'' functionality. We next give a brief overview of the IKOPS protocol. 

The main idea behind the IKOPS protocol is to have the server run an ``MPC in the head'' \cite{IPS08} \enote{give citation}. That is, the real server locally emulates the execution of a perfectly secure protocol $\Pi$ with many virtual servers performing the computation, and $2m$ virtual clients, denoted $\Cc_{1,0},\Cc_{1,1},\ldots,\Cc_{m,0},\Cc_{m,1}$, receiving output, where $m$ is the number of bits in the client's input $y$. The underlying protocol $\Pi$  computes (and distributes among the clients) a decomposable perfect randomized encoding (PRE) $\hat{f} = (\hat{f}_1,\ldots,\hat{f}_m)$ of $f$. Specifically, the output of client $\Cc_{j,b}$ in an execution of $\Pi$, where the randomness chosen for $\hat{f}$ is $r$, is $\hat{f}_j(b;r)$, i.e., the part of the encoding that corresponds to the $j$-th bit of $y$ being equal to $b$. 

The real client can then use OT in order to recover the correct output of the PRE and reconstruct the output $f(x,y)$. As part of the ``MPC in the head'' paradigm, the client and server jointly set up a watchlist (the views of some of the virtual servers) allowing the client to check consistency between the virtual servers' views and the virtual clients' views. If there was an inconsistency, the client outputs $f(x_0,y)$ for some default value $x_0\in\X$. However, it is unclear how to have the server send only some of the views according to the request of the client. \citet{IKOPS11} handle this by letting the client get each view with some constant probability independently of the other views.

The security of protocol as described so far can still be breached by a malicious server. By tampering with the outputs of the virtual clients, a malicious server could force the output of the real client to be $f(x,y)$ for some inputs $y$ and force the output to be $f(x_0,y)$ for other values of $y$, where the choice is completely determined by the adversary. To overcome this problem, the function $f$ is replaced with a function $f'$ where each bit $y_i$ is replaced with $m'$ random bit whose XOR equals to $y_i$, for some large $m'$. Here, the adversary does not have complete control over which inputs the client will output $f(x_0,y)$, and for which inputs it will output $f(x,y)$.
% There are now two cases. If a malicious server tampered with the outputs of $m'+1$ of the virtual clients that corresponds to the same input bit $y_i$, the client will output $f(x_0,y)$ for every $y$, hence this attack can be simulated. If for every input bit $y_i$, the server tampered with at most $m'$ of its outputs, then for every input $y$ with high probability (relative to the number of tampered clients) the client will notice the attack, hence in this case it will output $f(x_0,y)$ implying statistical security. %Observe that although the client can use OT in order to receive the correct $\v_{i,y_i}$'s, the parties need to use string-OT, while they only have access to bit-OT. This technicality can be overcome using the perfect reduction from $\sOT{1}{n}{s}$ to $\OT$  that was put forward in the elegant work of~\citet{BCS96}, which also constitutes one of the few examples of perfect reductions to $\bOT{1}{2}$ known so far.

Two problems arise when trying to use the IKOPS protocol to achieve perfect security. First, a malicious client could potentially receive the views of \emph{all virtual servers}, and as a result, it could learn the server's input. Second, with some non-zero probability, a malicious server might still be able to have the client output be $f(x_0,y)$ for some inputs $y$, but output $f(x,y)$ for other inputs $y$.

We solve the former issue, by having the client request views deterministically using $\sOT{t/2}{n}{s}$, where  $t$ bounds the number of corruptions allowed in $\Pi$. However, it is not known if implementing it in in the OT-hybrid model is even possible. Therefore, we slightly relax the security requirement, so that a malicious client will not be able to receive \emph{more than twice} of the number of views that an honest client receives. We then let the honest client ask for exactly $t/2$ of the views. The idea in constructing such a watchlist is the following. For each view of a virtual server, the real server send (via the OT functionality) either a masking of the view or a share of the concatenation of the masking, that is, the server's input to the OT is $(V_i\xor r_i,\myvec{r}[i])$ for every view of a virtual server $V_i$, where $\myvec{r}=\vect{r_1,\ldots,r_n}$ is a vector of random strings, and $\myvec{r}[i]$ is the $i$-th share of $\myvec{r}$. As a result, for each invocation of the OT, the client will be able to learn either a masked view or a share, which bounds the number of views it can receive.

To solve the second issue, it will be convenient to represent the server security requirement from a geometric viewpoint. To simplify the explanation in this introduction, we only focus on deterministic Boolean functions. We view the function as a $|\X|\times|\Y|$ matrix $M_f$, where $M_f(x,y)=f(x,y)$. Then perfect simulation of a malicious server is possible if and only if there exists a distribution $D$ over the rows of $M_f$ in the ideal-world, such that for every $y\in\Y$ the probability of the output being 1 in the real-world equals to the probability it happens in ideal-world, \ie  it equals to $\Pr_{x\from D}[f(x,y)=1]$. Stating this differently, simulation is possible if and only if the \emph{vector of outputs} $\vect{\Out_y}_{y\in\Y}$ in the real-world is in the \emph{convex-hull} of the rows of $M_f$.

Now, consider the IKOPS protocol. It could be the case that the vector of outputs has different errors in each coordinate created by an adversary, and hence is not necessarily inside the convex-hull of the rows of $M_f$. To fix this issue, instead of having the client output according to a default value in case of an inconsistency, the client will now output according to $v_y$, for some vector $\v$ \emph{strictly} inside the convex-hull of the rows. 
Let $p$ denote the probability of detecting an inconsistency
(more precisely, for each $y$ the probability $p_y$ of detecting an inconsistency is in $[p-\eps,p+\eps]$, for some small $\eps$).
Thus, the output vector of the client is close to the point $\q=p\cdot \v + (1-p)\cdot M_f(x,\cdot)$, give or take $\pm \eps$ in each coordinate, for some small $\eps$.
If $p$ is close to 1, this point $\q$ is close to $\v$, and since $\v$ is an internal point, $\q$ is also internal for a sufficiently small $\eps$. Otherwise, we utilize a special property of IKOPS protocol's security, where $\eps$ is bonded by $p\cdot \eps'$, namely $\eps$ depends on $p$, unlike the standard security requirement.

% If, for some input $y$, the client sees no inconsistencies, it will output according to a ``correct'' output distribution that is consistent with a distribution over the server's domain, give or take some small error of $\eps$ (the error results from the possibility that the server tampered with the outputs of the virtual clients and the real client did not notice)
% % , namely, $\vect{\Out_y}_{y\in\Y}$ will be inside the convex-hull, $\pm\eps$ of error in each coordinate.
% Assume that this event happens with probability $p$. Then with probability $1-p$ the client will see an inconsistency, and output according to a default value, namely, $\vect{\Out_y}_{y\in\Y}$ will now be on a vertex of the convex-hull. Since there is no guarantee as to why the convex combination of the points will be \emph{strictly} inside the convex-hull, adding the error could potentially put the vector of outputs outside of it, and therefore the protocol cannot be deemed perfectly server-secure. To fix this issue, whenever the client sees two views that are inconsistent, we instruct it to output with probability $v_y$, where $\v$ is a point that is \emph{strictly inside} the convex-hull of the rows of $M_f$, instead of a vertex as done in the IKOPS protocol. We show that $\vect{\Out_y}_{y\in\Y}$ is always inside some small neighborhood around $\v$, hence by choosing a small enough $\eps$, the entire neighborhood is contained inside the convex-hull implying that every attack can be simulated.

\deleted{
\paragraph{The IKOPS Protocol.}

\paragraph{Achieving Perfect Security.}\TODO{Add explanations}

In a nutshell, we start with a variant of~\cite{IKOPS11}'s protocol, which is statistically secure with abort. We rely on a special structure of the protocol, where the probability of $\bot$ is independent of the input, up to negligible differences.\footnote{In~\cite{IKOPS11},
they also put forward a protocol which is fully statistically secure, essentially by setting the server's input to some default value instead of outputting $\bot$. For the purpose of making the protocol perfectly secure, we make a different choice for $\bot$.}

To make the protocol perfectly secure against malicious clients, we modify the so called ``watchlists'' used in~\cite{IKOPS11}  to include exactly $k$ out of $n$ virtual servers, rather than enlist each server with a certain probability. Then, to make it perfectly secure against malicious servers, we rely on geometric interpretation of security (as previously used in the fairness literature), and come up with a way to replace $\bot$ in the ideal model simulating a corrupted server for functions of \emph{full dimension}.
}
%For instance, Cleve's impossibility result, and~\cite{GHKL08}'s result for functions with a so called \emph{embedded xor}, in fact prove that certain functionalities including coin-tossing require round complexity of $\omega_k(1)$. This puts, coin tossing much higher in the round complexity hierarchy than all client-server functionalities which have protocols with round complexity of 1.

% We revisit the question of what are the simplest idealized functionalities required for perfect fully secure two-party computation (2PC).
% %Searching for the simplest possible setting, we focus on computationally unbounded parties.
% As $\bOT{1}{2}$ is complete for several useful security notions, in this work we focus on $\bOT{1}{2}$ as a candidate. While the setting of statistical security is quite well understood, the question of perfect security is almost entirely open. 

% Briefly, in the $\OThybrid$ model, in addition to sending messages among themselves, the parties are allowed to make any number of calls to an idealized secure implementation of $\bOT{1}{2}$. 
% More precisely, we assume that in every round, one party either sends a message over the channel connecting the parties, or makes a call to $\ell$ ideal executions of the OT \emph{in parallel}, namely, the receiver submits all inputs and receives all outputs simultaneously - he may not choose some of the inputs based on outputs of other OT calls. Here we assume that it is always the case where the same party plays the sender in the call for the OT. Here we assume that the parties are given a stronger oracle. %that securely evaluates ${\bOT{1}{2}}^{\ell}$, where $\ell$ may vary between rounds (in particular, the receiver submits all inputs and receives all outputs simultaneously - he may not choose some of the inputs based on outputs of other OT calls).

% %Let us briefly review some key results on statistically and computationally secure protocols in the $\OThybrid$ model. %In this discussion we consider the more standard setting where protocols should be efficient, unless stated otherwise.
% %In this work, and when discussing efficient protocols from the literature, we focus on finite functionalities, so the complexity is measured in terms of a security parameter $1^{\kappa}$ (where the simulation error is negligible in $\kappa$).
 
% \paragraph{Statistically Secure 2PC in the $\OTHybrid$ Model.} Even inefficiently, statistically secure computation is known to be impossible in the plain model even against semi-honest adversaries for some simple functions such as AND and OR~\cite{CK89}.
% Here even a simulation error of, say, $1/3$ is not achievable.
% Among the functionalities that are efficiently semi-honestly computable even with perfect security, some are not computable with statistical security against malicious parties in the plain model.

% In particular, Cleve~\cite{Cleve86} has demonstrated that even the simple functionality of coin tossing where both parties output the same random bit, is not efficiently computable with statistical security. This impossibility extends to the $\OThybrid$ model.

% As a consequence, the 2PC literature (more generally, MPC without honest majority) has settled on a weaker notion of security with abort where the ideal world adversary $A$ has the extra power allowing it to learn the output $f_A(x,y)$ first, and then decide whether to instruct the TP to send the honest party $B$ its output $f_B(x,y)$ or to send it $\bot$ (abort). General purpose 2PC protocols that are statistically secure with abort for any 2PC functionality have been developed starting with ~\cite{GMW91} in the computational setting, followed by~\cite{Killian88}, that only assumes an OT oracle (while~\cite{GMW91} relies on additional cryptographic primitives,\cite{Killian88} demonstrates how to implement these and many other cryptographic primitives using OT). 

% A more recent alternative relaxation of statistical security~\cite{GK10}
% allows for a polynomial error $poly(k^{-1})$, while requiring the parties are still efficient. In~\cite{GK10}, it is proved that all 2PC functionalities are computable with statistical security in the OT hybrid model according to this notion. They refer to this notion as $1/p$-security.

% Furthermore, their results can be interpreted as statistically secure protocols in the OT hybrid model in our setting (when efficiency is not required).% These generalize previous constructions for coin tossing, that also satisfy this security notion.

% Also, quite surprisingly, it turns out that many functionalities can be evaluated with statistical security by efficient protocols as discovered in the seminal work~\cite{GHKL08}, followed by works as~\cite{Ash14,asharov2015complete}. In particular,~\cite{asharov2015complete} completes the characterization of symmetric Boolean functions
% (where both parties receive the same output)
 
% However, all known protocols for such functions require round complexity of $\omega_k(1)$. In~\cite{IKOPS11}, a 1-round protocol is presented for client-server functionalities, where only the client learns an output. The protocol has a single round, and makes a single call to an  ${\bOT{1}{2}}^l$ oracle (does not use the channel connecting the parties).
% Furthermore, the protocol's computational and communication complexity are efficient in $k$. So, while all 2PC functionalities can be evaluated with statistical security in the OT hybrid model (possibly inefficiently), there are provable gaps in their round complexity. 

% For instance, Cleve's impossibility result, and~\cite{GHKL08}'s result for functions with a so called \emph{embedded xor}, in fact prove that certain functionalities including coin-tossing require round complexity of $\omega_k(1)$. This puts, coin tossing much higher in the round complexity hierarchy than all client-server functionalities which have protocols with round complexity of 1.

% \paragraph{Perfectly secure 2PC in the $\OThybrid$ model.}
% While the statistical setting is qualitatively understood (for unbounded parties), and even the round complexity of protocols is partially understood, much less is known in the perfect setting. 
% The ultimate goal of this work is to understand which functionalities can be evaluated with perfect security in the OT hybrid model.

% On the positive side, we are aware of only a handful of perfect reductions to $\bOT{1}{2}$. One is from string-OT~\cite{BCS96}, and one from $\TO{1}{2}$~\cite{WolfW06}, which is the same as $\bOT{1}{2}$ where the roles of the parties are reversed. The first one sends no bits over the point to point channel, and only uses to ${\bOT{1}{2}}^l$ oracle, while the latter only requires only a single bit of additional communication over the channel.
% On the negative side, 2PC functionalities requiring $\omega_k(1)$ rounds mentioned above are not perfectly computable. 

% Thus, the state of affairs is that most 2PC functionalities that are computable with fairness remain unclassified as to perfect security. 

% \subsection{Our results}

% Motivated by the relative ease of client-server functionalities for statistical security in the $\OThybrid$ model, we start with client-server functionalities.\\

% \emph{Question 1. Characterize the set of 2PC functionalities (not necessarily Boolean) which are perfectly secure in the $\OThybrid$ model.
% As a starting point, can we characterize client-server functionalities ?}
 
% We make progress on the above question, and discover a broad class of 2PC functionalities computable with perfect security.

% \begin{theorem}[Informal]
% 	Let $f:X\times Y\rightarrow Z$ be a deterministic finite client-server functionality. If the truth table of $f$ is full dimensional (as defined in~\cite{Ash14}), then $f$ is computable with perfect security in the $\OThybrid$ model.
% \end{theorem}

% We do not know whether all client-server functionalities are computable with perfect security, and leave it as an interesting open question.

% In a nutshell, we start with a variant of~\cite{IKOPS11}'s protocol, which is statistically secure with abort. We rely on a special structure of the protocol, where the probability of $\bot$ is independent of the input, up to negligible differences.\footnote{In~\cite{IKOPS11},
% they also put forward a protocol which is fully statistically secure, essentially by setting the server's input to some default value instead of outputting $\bot$. For the purpose of making the protocol perfectly secure, we make a different choice for $\bot$.}

% To make the protocol perfectly secure against malicious clients, we modify the so called ``watchlists'' used in~\cite{IKOPS11}  to include exactly $k$ out of $n$ virtual servers, rather than enlist each server with a certain probability. Then, to make it perfectly secure against malicious servers, we rely on geometric interpretation of security (as previously used in the fairness literature), and come up with a way to replace $\bot$ in the ideal model simulating a corrupted server for functions of \emph{full dimension}.

\deleted{
\subsection{Future work - more on the relation to fairness}
\TODO{Read}
Trivially, if a 2PC functionality has a perfectly secure protocols in the OT hybrid model it is also securely computable with fairness.
The other direction is not true. As follows from the $\omega_k(1)$ bound in~\cite{GHKL08} for symmetric functions with an embedded XOR, and the  construction of~\cite{Ash14} for all full dimensional functions (some of which have an embedded XOR), fairness does not imply perfect security. 

The work of~\cite{Ash14} puts forward a class of symmetric functions that have protocols which are statistically secure with fairness, for which our protocols do not work. The condition characterizing the functions that can be handled by his protocol is identical to ours. 

\begin{theorem}[Informal~\cite{Ash14}]
Every symmetric function $f(x,y)$ such that 	
the truth table $F$ of $f(x,y)$ is \emph{full-dimensional} (when considering the set of rows of the matrix representing $F$), can be evaluated with full security. 
\end{theorem}

This is precisely the condition we impose, where the columns of $F$ are labeled by $X$, and the rows are labeled by $Y$. However, if $F^T$
rather than $f$ is of full dimension, since $f$ is symmetric, reversing the roles of the row player and the column player allows to securely compute $f'(y,x)=f(x,y)$, and thus compute $f(x,y)$. 
For client-server functionalities, this transpose is not possible, as the roles of the parties in the protocol are not symmetric.

This is interesting, since client-server functionalities are particularly easy to implement with (statistical) fairness, while symmetric functionalities are less so. However, even symmetric functionalities that are computable with full statistical security may not be computable with perfect security even in their .

This provides guidance for candidate client-server functionalities  
with no perfect protocols to look at first.
\emph{Question 1.1.
Consider $f(x,y)$ for which $F$ is not full dimensional, but $F^T$ is.
Such functions have a protocol with full statistical security in the $\OThybrid$ model~\cite{Ash14}, but are not covered by our construction. Do all these function have a perfect protocol in the OT hybrid model? 
}

%Our result in particular implies that the subclass of .\footnote{In fact, our constructions satisfy the stronger standard defintion where efficient adversaries have an efficient simulator.}

Another interesting open question on perfect security is.\\ 

\emph{Question 2. For (inefficient) statistical security it follows from the fairness literature that increasing round complexity helps to evaluate more functions (some examples for efficient 2PC are also known: combining~\cite{Ash14,GHKL08} to obtain certain functions with embedded xor).
Does increasing round complexity beyond 1 allow to perfectly evaluate more functions ? This relates to both client-server and other types of 2PC functionalities.} \\

One approach towards constructing such protocols (for general 2PC functionalities, not just client-server ones) is modifying~\cite{Ash14}'s GHKL-style protocols for general (possibly asymmetric) functions. 

Here full dimension properties of $f$ alone will not generally suffice, as for (symmetric) functionalities with an embedded xor every protocol with error $neg(k)$ requires $\omega_k(1)$ rounds~\cite{GHKL08} so perfect security is in fact impossible.
}

% \subsection{Additional Related Work}
% Perfectly secure and unconditional protocols were first considered in the multiparty setting \citet*{BGW88} and \citet*{chaum1988multiparty}.\TODO{Finish}

\subsection{Organization} In \cref{sec:prelim} we provide some notations and definitions that we use in this work, alongside some required mathematical background. \cref{sec:main} is dedicated to expressing security in geometrical terms and the formal statement of our result. In \cref{sec:geom,sec:IKOPS} we present the proof of the main theorem. In \cref{sec:limitation} we show that the analysis of our protocol for Boolean functions is tight.

\section{Preliminaries}\label{sec:prelim}
\subsection{Notations}
We use calligraphic letters to denote sets, uppercase for random variables and matrices, lowercase for values, and we use bold characters to denote vectors and points. All logarithms are in base 2. For $n\in\N$, let $[n]=\{1,2\ldots n\}$. For a set $\S$ we write $s\from\S$ to indicate that $s$ is selected uniformly at random from $\S$. Given a random variable (or a distribution) $X$, we write $x\from X$ to indicate that $x$ is selected according to $X$. We use $\poly$ to denote an unspecified polynomial, and we use $\polylog$ to denote an unspecified polylogarithmic function. %A PPT stands for probabilistic polynomial time. 
%The support of a distribution $D$ over a finite set $\S$, denoted $\Supp(D)$, is defined as $\left\{s\in\S\cond D(s)>0\right\}$. 
For a randomized function (or an algorithm) $f$ we write $f(x)$ to denote the random variable induced by the function, and write $f(x;r)$ to denote the value when the randomness of $f$ is fixed to $r$.

For a vector $\v\in\R^n$, we denote its $i$-th component with $v_i$ \deleted{ we let $\norm{\v}{1}=\sum_{i}v_i$ be its $\ell_1$ norm, we let $\norm{\v}{2}=\sqrt{\sum_{i}v_i^2}$ be its Euclidean norm,} and we let $\norm{\v}{\infty}=\max_i |v_i|$ denote its $\ell_\infty$ norm. We denote by $\ones_n$ ($\zeros_n$) the all-ones (all-zeros) vector of dimension $n$. A vector $\p\in\R^n$ is called a probability vector if $\p_i\geq 0$ for every $i\in[n]$ and $\sum_{i=1}^n p_i=1$. 

For a matrix $M\in \R^{n\times m}$, we let $M\of{i,\cdot}$ be its $i$-th row, we let $M\of{\cdot,j}$ be its $j$-th column, and we denote by $M^T$ the transpose of $M$. For a pair of matrices $M_1\in \R^{n\times m_1},M_2\in \R^{n\times m_2}$, we denote by $\left[M_1||M_2\right]$ the concatenation of $M_2$ to the right of $M_1$.

\subsection{Cryptographic Tools}
% A function $\mu(\cdot)$ is called negligible, if for every polynomial $p(\cdot)$ and all sufficiently large $n$, it holds that $\mu(n)<1/p(n)$. We write $\negl\of{\cdot}$ to denote an unspecified negligible function. 

%A \emph{distribution ensemble} $X=\set{X_{a,n}}_{a\in\D_n,n\in\N}$ is an infinite sequence of random variables indexed by $a\in\D_n$ and $n\in\N$, where $\D_n$ is a domain that might depend on $n$. The statistical distance between two finite distributions is defined as follows.

\begin{definition}\label{def:statDist}
	The statistical distance between two finite random variables $X$ and $Y$ is
	$$\SD\of{X,Y}=\frac12\sum_{a}\abs{\pr{X=a}-\pr{Y=a}}.$$
\end{definition}
\deleted{It is a simple fact that statistical distance can be written using the $\ell_1$ norm. Let $\p$ and $\q$ denote the associated probability vectors of $X$ and $Y$ respectively, \ie $p_x=\pr{X=x}$ and $q_y=\pr{Y=y}$. Then
$$\SD\of{X,Y}=\half\cdot\norm{\p-\q}{1}.$$}

\subsubsection*{Secret Sharing Schemes.} A $(t+1)$-out-of-$n$ secret-sharing scheme is a mechanism for sharing data among a set of parties $\set{\Pc_1,\ldots,\Pc_n}$, such that every set of size $t+1$ can reconstruct the secret, while any smaller set knows nothing about the secret. In this work, we rely on Shamir's secret sharing scheme \cite{Shamir79}.

In a $(t+1)$-out-of-$n$ Shamir's secret sharing scheme over a field $\field$, where $|\field|>n$, a secret $s\in\field$ is shared as follows: A polynomial $p(\cdot)$ of degree at most $t+1$ over $\field$ is picked uniformly at random, conditioned on $p(0)=s$. Each party $\Pc_i$, for $1\leq i\leq n$, receives a share $s[i]:=p(i)$ (We abuse notation and let $i$ be the element in $\field$ associated with $\Pc_i$).

\subsubsection*{Decomposable Randomized Encoding.}
We recall the definition of randomized encoding \cite{Yao82,AIK04}. They are known to exists unconditionally \cite{IK02,AIK04}.

\begin{definition}[Randomized Encoding]\label{def:RPE}
Let $f:\zo^n\mapsto\mathcal{Z}$ be some function. We say that a function $\hat{f}:\zo^n\times\mathcal{R}\mapsto\mathcal{W}$ is a perfect randomized encoding (PRE) of $f$ if the following holds.

\begin{description}
	\item[Correctness:] There exists a decoding algorithm $\mathsf{Dec}$ such that for every $x\in\zo^n$
    $$\Pr_{r\from\mathcal{R}}\left[\mathsf{Dec}\of{\hat{f}\of{x;r}}=f(x)\right]=1.$$
    
    \item[Privacy:] There exists a randomized algorithm $\Sim$ for every $x\in\zo^n$ it holds that
    $$\Sim\of{f(x)}\equiv\hat{f}\of{x;r},$$
    where $r\from\mathcal{R}$.
\end{description}
\end{definition}

\begin{definition}[Decomposable Randomized Encoding]
For every $x\in\zo^n$, we write $x=x_1,\ldots,x_n$, where $x_i$ is the $i$-th bit of $x$. A randomized encoding $\hat{f}$ is said to be \emph{decomposable} if it can be written as $$\hat{f}\of{x;r}=\vect{\hat{f}_0\of{r},\hat{f}_1\of{x_1;r},\ldots,\hat{f}_n\of{x_n;r}},$$
where each $\hat{f}_i$ can be written as one of two vectors that depends on $x_i$, \ie we can write it as $\v_{i,x_i}$, where $(\v_{i,0},\v_{i,1})$ depends on the randomness $r$.
\end{definition}

\subsection{Mathematical Background}
\begin{definition}[Convex Combination and Convex Hull]
Let $\V=\{\v_1,\ldots,\v_m\}\subseteq\R^n$ be a set of vectors. A convex combination is a linear combination $\sum_{i=1}^m \alpha_i\cdot\v_i$ where $\sum_{i=1}^m\alpha_i=1$ and $\alpha_i\geq 0$ for all $1\leq i\leq m$. The convex hall of $\V$, denoted
$$\CH{\V}=\set{\sum_{i=1}^m\alpha_i\cdot\v_i\cond \sum_{i=1}^m\alpha_i=1\text{ and } \alpha_i\geq 0 \text{ for all } i\in[m]},$$ 
is the set of all vectors that can be represented as a convex combination of the vectors in $\V$. For a matrix $M=[\v_1||\ldots||\v_m]$ we let $\CH{M}=\CH{\set{\v_1,\ldots,\v_m}}$.
\end{definition}

\begin{definition}[Affine Hull]
	For a set of vectors $\V=\{\v_1,\ldots,\v_m\}\subseteq\R^n$, we define their \emph{affine hull} to be the set
    $$\aff{\V}=\set{\sum_{i=1}^m\alpha_i\cdot\v_i\cond \sum_{i=1}^m\alpha_i=1}.$$
    For a matrix $M=[\v_1||\ldots||\v_m]$ we let $\aff{M}=\aff{\set{\v_1,\ldots,\v_m}}$.
    %dimension $\affine{\V}$ as the dimension of the vector space spanned by the set $\set{\v_i-\v_1:i\geq 2}$. 
\end{definition}

\begin{definition}[Affine Independence]
A set of points $\v_1,\ldots,\v_m\in\R^n$ is said to be \emph{affinely independent} if whenever $\sum_{i=1}^m\alpha_i\cdot\v_i=\zeros_n$ and $\sum_{i=1}^m\alpha_i=0$, then $\alpha_i=0$ for every $i\in[m]$. Observe that $\v_1,\ldots,\v_m$ are affinely independent if and only if $\v_2-\v_1,\ldots,\v_m-\v_1$ are linearly independent.
\end{definition}

For a square matrix $M\in\R^{n\times n}$, we denote by $\det{M}$ the determinant of $M$, and we denote by $M_{i,j}$ the $(i,j)$'th cofactor of $M$, which is the $(n-1)\times(n-1)$ matrix obtained by removing the $i$'th row and $j$'th column of $M$.
It is well known that:
\begin{fact}\label{fact-cramer}
Let $M\in\R^{n\times n}$ be an invertible matrix. Then for every $i,j\in[n]$ it holds that $\abs{M^{-1}\of{i,j}}=\abs{\det{M_{j,i}}/\det{M}}$.
\end{fact}

%\section{Secure two-party Computation In The Client-Server Model}
\subsection{The Model of Computation}
We follow the standard \emph{ideal~vs.~real} paradigm for defining security. Intuitively, the security notion is defined by describing an ideal functionality, in which both the corrupted and non-corrupted parties interact with a trusted entity. A real-world protocol is deemed secure if an adversary in the real-world cannot cause more harm than an adversary in the ideal-world. This is captured by showing that an ideal-world adversary (simulator) can simulate the full view of the real world adversary. 

 We focus our attention on the \emph{client-server model}. In this model a server $\Sc$ holds some input $x$ and a client $\Cc$ holds some input $y$. At the end of the interaction the client learns the output of some function of $x$ and $y$, while the server learns nothing. We further restrict ourselves to allow only a \emph{single round} of interaction between the two parties, however, as only trivial functionalities are computable in this setting, the parties interact in the $\OThybrid$ model. 
%  As discussed in \cref{intro} this is motivated by the fact that statistical full-security can be achieved in this setting for all functionalities \cite{IKOPS11}. 
We next formalize the interaction done in this model.

\subsubsection*{The OT Functionality.}
We start by formally defining the (family) of the OT functionality. The $\bOT12$ functionality, is a two-party client-server functionality in which the server inputs a pair of bit-messages $a_0$ and $a_1$, and the client inputs a single bit $b$. The server receives $\bot$ and the client receives $a_b$. For every natural number $\ell\geq1$, we define the functionality $\bOT12^{\ell}$ as follows. Let $\myvec{a}=\vect{a_0^i,a_1^i}_{i=1}^{\ell}$ and let $\myvec{a}=\vect{a_i}_{i=1}^{\ell}$, where $a_0^i,a_1^i,b_i\in\zo$ for every $i$. We let $\myvec{a}[\myvec{b}]:=\vect{a^i_{b_i}}_{i=1}^{\ell}$. The functionality is then defined as $\vect{\myvec{a},\myvec{b}}\mapsto\vect{\bot,\myvec{a}[\myvec{b}]}$. That is, it is the equivalent of computing $\ell$ times in parallel the $\bOT12$ functionality. Finally, we let $\OTfunc=\set{\bOT12^{\ell}}_{\ell\geq1}$.

A generalization of $\bOT{1}{2}$ is the $\bOT{1}{n}$ functionality, which lets the client pick one out of $n$ bits $a_1,a_2,\ldots,a_n$ supplied by the server, and on input $i\in[n]$ the client learns $a_i$. This can be further generalized to $\sOT{1}{n}{s}$ where the $n$ bits are replaced by strings $a_1,\ldots,a_n\in \{0,1\}^s$, and this can generalized even further to $\sOT{k}{n}{s}$ where the input $i$ of the client is replaced with $k$ inputs $i_1,\ldots,i_k\in[n]$, and it receives $a_{i_1},\ldots,a_{i_k}$.

\subsubsection*{The 1-Round \texorpdfstring{$\OTHybrid$}{$\OTHybrid$} Model.}
We next describe the execution in the \emph{1-round $\OThybrid$ model}. In the following we fix a (possibly randomized) client-server function $f:\X\times\Y\mapsto\Z$. A protocol $\Pi$ in the \emph{1-round $\OThybrid$ model} with security parameter $\kappa$, is a triple of randomized functions $\vect{\srvr,\clnt,\local}$. The server and client use the function $\srvr$ and $\clnt$ respectively to obtain messages to send to the OT. The client then compute some local function $\local$ on its view to obtain an output. Formally, the computation is done as follows.
\begin{description}
\item[Inputs:] The server $\Sc$ holds input $x\in\X$ and the client $\Cc$ holds input $y\in\Y$. In addition, both parties holds the security parameter $1^{\kappa}$.

\item[Parties send inputs to the OT:] $\Sc$ samples $2\ell\of{\kappa}$ bits $\myvec{a}=\srvr\of{x,1^{\kappa}}$, and $\Cc$ samples $\ell\of{\kappa}$ bits $\myvec{b}=\clnt\of{y,1^{\kappa}}$, for some $\ell$ determined by the protocol. $\Cc$ then receives $\myvec{a}[\myvec{b}]$ from the OT.

\item[Outputs:] The server $\Sc$ outputs nothing, while The client $\Cc$ computes the local function $\local\of{y,\b,\a[\b],1^{\kappa}}$ and outputs its result.
\end{description}

We refer to the $\ell\of{\kappa}$ used in the protocol as the communication complexity ($\CC$) of $\Pi$.

In the setting of two-party computation, we consider an adversary $\adv$ that controls a single party. The adversary has access to the full view of that party. We assume the adversary is malicious, that is, it may instruct the corrupted party to deviate from the protocol in any way it chooses. The adversary is non-uniform, and is given an auxiliary input $\aux$. %The adversary is static, that is, it chooses the subset it corrupts prior to the execution of the protocol.
For simplicity we do not concern ourselves with the efficiency of the protocols or the adversaries, namely, we assume that the parties and the adversary are unbounded.

For inputs $x\in\X$, $y\in\Y$, and $\kappa\in\N$, we let $\Out^{\HYBRID}_{\adv\of{x,\aux},\Pi}\of{x,y,1^{\kappa}}$ denote the output of the client in a random execution of $\Pi$, when $\adv$ corrupts the server, and we let $\View^{\HYBRID}_{\adv\of{y,\aux},\Pi}\of{x,y,1^{\kappa}}$ denote the adversary's view in a random execution of $\Pi$, when $\adv$ corrupts the client.


\subsubsection*{The ideal Model.}
We now describe the interaction in the ideal model, which specifies the requirements for fully secure computation of the function $f$ with security parameter $\kappa$. Let $\adv$ be an adversary in the ideal-world, which is given an auxiliary input $\aux$ and corrupts one of the parties.

\subsubsection*{The ideal model -- full-security.}
\begin{description}

\item[Inputs:] The server $\Sc$ holds input $x\in\X$ and the client $\Cc$ holds input $y\in\Y$. The adversary is given an auxiliary input $\aux\in\zo^{*}$ and the input of the corrupted party. The trusted party $\trustp$ holds $1^{\kappa}$.

\item[Parties send inputs:] The honest party sends its input to $\trustp$. The adversary sends a value $w$ from its domain as the input for corrupted party.

\item[The trusted party performs computation:] $\trustp$ selects a random string $r$ and computes $z=f\of{x,w;r}$ if $\Cc$ is corrupted and  computes $z=f(w,y;r)$ if $\Sc$ is corrupted. $\trustp$ then sends $z$ to $\Cc$.

\item[Outputs:] An honest server outputs nothing, an honest client output $z$, and the malicious party outputs nothing. The adversary outputs some function of its view.
\end{description}

For inputs $x\in\X$, $y\in\Y$, and $\kappa\in\N$, we let $\Out^{\IDEAL}_{\adv\of{x,\aux},f}\of{x,y,1^{\kappa}}$ denote the output of the client in a random execution of of the above ideal-world process, when a $\adv$ corrupts the server, and we let $\View^{\IDEAL}_{\adv\of{y,\aux},f}\of{x,y,1^{\kappa}}$ be the view description being the \emph{output} of $\adv$ in such a process, when $\adv$ corrupts the client.

We next present the definition for security against malicious adversaries. The definition we present is tailored to the setting of the 1-round two-party client-server in the $\OThybrid$ model.
\begin{definition}[malicious security]\label{def:perfectsec}
	Let $\Pi=(\srvr,\clnt,\local)$ be a protocol for computing $f$ in the 1-round $\OThybrid$ model. Let $\eps$ be a function of the security parameter.
    \begin{enumerate}
    \item\label{item:corr}\normalfont{\textbf{Correctness:}} We say that $\Pi$ is \emph{correct} if for all $\kappa\in\N$, $x\in\X$, and $y\in\Y$
  
  $$\Pr_{\substack{\a=\srvr\of{x,1^{\kappa}},\\\b=\clnt\of{y,1^{\kappa}}}}\left[\local\of{y,\b,\a[\b],1^{\kappa}}=f(x,y)\right]=1.$$
    
    \item\label{item:malser}\normalfont{\textbf{Server Security:}} We say that $\Pi$ is \emph{$\eps$-server secure}, if for any non-uniform adversary $\adv$ corrupting the server in the $\OThybrid$ world, there exists a non-uniform adversary $\Sim_{\adv}$ (called the simulator) corrupting the server in the ideal-world, such that for all $\kappa\in\N$, $x\in\X$, $y\in\Y$, and $\aux\in\zo^*$ it holds that
    $$\SD\of{\Out^{\HYBRID}_{\adv\of{x,\aux},\Pi}\of{x,y,1^{\kappa}},~\Out^{\IDEAL}_{\Sim_{\adv}\of{x,\aux},f}\of{x,y,1^{\kappa}}}\leq\eps\of{\kappa}.$$
    We say that $\Pi$ has perfect server security if it is 0-server secure.
    
    \item\label{item:malcl}\normalfont{\textbf{Client Security:}} We say that $\Pi$ is \emph{$\eps$-client secure}, if for any non-uniform adversary $\adv$ corrupting the client in the $\OThybrid$ world, there exists a non-uniform simulator $\Sim_{\adv}$ corrupting the client in the ideal-world, such that for all $\kappa\in\N$, $x\in\X$, $y\in\Y$, and $\aux\in\zo^*$ it holds that
    $$\SD\of{\View^{\HYBRID}_{\adv\of{y,\aux},\Pi}\of{x,y,1^{\kappa}},~\View^{\IDEAL}_{\Sim_{\adv}\of{y,\aux},f}\of{x,y,1^{\kappa}}}\leq\eps\of{\kappa}.$$
     We say that $\Pi$ has perfect client security if it is 0-client secure.
    \end{enumerate}
    
     We say that $\Pi$ computes $f$ with \emph{$\eps$-statistical full-security}, if $\Pi$ is correct, is $\eps$-server secure, and is $\eps$-client secure. Finally, we say that $\Pi$ computes $f$ with \emph{perfect full-security}, if it computes $f$ with \emph{$0$-statistical full-security}.
\end{definition}

\deleted{We next describe a stronger notion for security against a corrupt server.
\begin{definition}\label{def-enh-cl}
Let $f:(\X\cup\set{\bot})\times\Y\mapsto\set{\bot,0,\ldots,k-1}$. Assume that $f(x,y)=\bot$ if and only if $x=\bot$. Let $\Pi=\vect{\srvr,\clnt,\local}$ be protocol which computes $f$ in the 1-round $\OThybrid$ model with $\CC$ of $\ell$. We say that $\Pi$ computes $f$ with \emph{strong $\eps$-server security} if %in addition to being $\eps$-server secure, $\Pi$ also satisfies 
the following holds. For any possible message $\a^*\in\zo^{2\ell}$ sent by a corrupt server, there exists a distribution $X^*$ over $(\X\cup\set{\bot})$ such that for all $y\in\Y$
$$
\SD_{\substack{\myvec{b}\from\clnt(y),\\x\from X^*}}
\of{\local(y,\myvec{b},\myvec{a}^*[\myvec{b}],1^{\kappa}), f(x,y)}\leq \eps\cdot p_{\bot},
$$
where $p_\bot=\Pr_{x\from X^*}[x=\bot]$. \footnote{This is stronger than the $\eps$-server security property, as this requires only a distance bound of $\eps\cdot p_\bot$ rather than $\eps$.} 
\end{definition}\TODO{Think whether or not we should move this to the main part of the paper}
}

To alleviate notation, from now on we will completely remove $1^{\kappa}$ from the input the functions $\srvr$, $\clnt$, and $\local$, and remove $\kappa$ from $\ell$ and $\eps$. Statistical security will now be stated as a function of $\eps$.

We next give another notion of security against a malicious server. This notion is a generalization of the ``input-value disjunction'' security used by \cite{IKOPS11}. It captures adversaries that can force the output of the client to be of a certain value for specific client-inputs chosen by the adversary, while on other inputs, the client will receive the ``correct'' output. We only phrase the definition for perfect security.

% In this notion we modify the ideal-world in some way. On the one hand, the server is deterministic, while on the other hand, it may choose some predicate, such that the client will receive an output if its input satisfies the predicate.%\footnote{This is a relaxation as it allows for conditional abort. It also strengthens the definition in the sense that every deterministic server strategy induces a single effective input $x$, rather than a distribution.}

% \begin{definition}
% Let $f:(\X\cup\set{\bot})\times\Y\mapsto\Z$. In the model with \emph{input-value}, we modify the ideal-world so that the malicious simulator for the server, in addition to sending an input $x^*\in\X$, it also gives the trusted party $\trustp$ a predicate $P:\Y\mapsto\zo$. $\trustp$ then sends to the client $f(x^*,y)$ if $P(y)=0$, and $f(\bot,y)$ otherwise.\footnote{This is somewhat different from standard notions where the client receive $\bot$ rather then server having an input $\bot$.} We let $\Out^{\ID}_{\adv\of{x,\aux},f}\of{x,y,1^{\kappa}}$ denote the output of the client in a random execution of of the above ideal-world process, with an $\adv$ corrupting the server.

% Let $\Pi$ be a protocol that computes $f$ in the 1-round $\OThybrid$ model and let $\eps(\cdot)$ be a function of the security parameter. We say that $\Pi$ computes $f$ with \emph{$\eps$-input-value security}, if for every non-uniform \emph{deterministic} adversary $\adv$ corrupting the server in the $\OThybrid$ world, there exists a non-uniform \emph{deterministic} adversary $\Sim_{\adv}$ corrupting the server in the input-value ideal-world, such that for all $\kappa\in\N$, $x\in\X$, $y\in\Y$, and $\aux\in\zo^*$ it holds that $$\SD\of{\Out^{\HYBRID}_{\adv\of{x,\aux},\Pi}\of{x,y,1^{\kappa}},~\Out^{\ID}_{\Sim_{\adv}\of{x,\aux},f}\of{x,y,1^{\kappa}}}\leq\eps\of{\kappa}.$$
% We say that $\Pi$ computes $f$ with \emph{perfect input-value security}, if it computes $f$ with \emph{0-input-value security}.
% \end{definition}\TODO{Find definition in the literature.}

\begin{definition}
Let $f:\X\times\Y\mapsto\Z$. In the \emph{input-value} model, we modify the ideal-world so that the malicious simulator for the server, in addition to sending an input $x^*\in\X$, also gives the trusted party $\trustp$ a predicate $P:\Y\mapsto\zo$. $\trustp$ then sends to the client $f(x^*,y)$ if $P(y)=0$, and $\bot$ otherwise. We let $\Out^{\ID}_{\adv\of{x,\aux},f}\of{x,y}$ denote the output of the client in a random execution of of the above ideal-world process, with $\adv$ corrupting the server.

Let $\Pi$ be a protocol that computes $f$ in the 1-round $\OThybrid$ model\deleted{ and let $\eps>0$}. We say that $\Pi$ has \emph{perfect input-value security}, if for every non-uniform \bnote{I couldn't find where we used this restriction} adversary $\adv$ corrupting the server in the $\OThybrid$ world, there exists a non-uniform adversary $\Sim_{\adv}$ corrupting the server in the input-value ideal-world, such that for all $x\in\X$, $y\in\Y$, and $\aux\in\zo^*$ it holds that 
$$\Out^{\HYBRID}_{\adv\of{x,\aux},\Pi}\of{x,y}\equiv\Out^{\ID}_{\Sim_{\adv}\of{x,\aux},f}\of{x,y}.$$
\deleted{$$\SD\of{\Out^{\HYBRID}_{\adv\of{x,\aux},\Pi}\of{x,y},~\Out^{\ID}_{\Sim_{\adv}\of{x,\aux},f}\of{x,y}}\leq\eps.$$
We say that $\Pi$ computes $f$ with \emph{perfect input-value security}, if it computes $f$ with \emph{0-input-value security}.}
\end{definition}\bnote{I think we should rename it to ``input-value'' so it will be more consistent with the IVD security from IKOPS.}

\section{A Class of Perfectly Computable Client-Server Functions}\label{sec:main}
In this section, we state the main result of this paper -- presenting a large class of two-party client-server functions that are computable with perfect security. We start with presenting a geometric view of computation in our model. We take a similar approach to that of~\cite{Ash14} to representing the server-security requirements geometrically.

\subsection{A Geometrical Representation of the Security Requirements}
\paragraph{Boolean functions.}
We start with giving the details for (randomized) Boolean functions. For any function $f:\X\times\Y\mapsto\zo$ we associate a matrix $M_f$ defined as \deleted{$M_f\of{x,y}=f(x,y)$} $M_f(x,y)=\pr{f(x,y)=1}$. Let $\X=\set{x_1,\ldots,x_n}$.
Observe that in the ideal-world, every strategy that is employed by a simulator corrupting the server can be encoded with a probability vector $\p\in\R^{n}$, where $p_i$ corresponds to the probability of sending $x_i$ to $\trustp$. Therefore, if the input of the client is $y$, then the probability that the output is 1, equals to $\p^T\cdot M_f(\cdot,y)$. 
On the other hand, in the 1-round $\OThybrid$ model, a malicious server can only choose a string $\a^*\in\zo^{2\ell}$ and send in to the OT. Then on input $y\in\Y$, the probability the client outputs 1 is exactly
$$q^{\Pi}_y\of{\a^*}:=\Pr_{\b=\clnt\of{y}}\left[\local\of{y,\b,\a^*[\b]}=1\right].$$
Therefore, perfect simulation is possible if and only if for every $\a^*\in\zo^{2\ell}$ there exists a probability vector $\p\in\R^n$ such that for every $y\in\Y$
$$\p^T\cdot M_f\of{\cdot,y}=q^{\Pi}_y\of{\a^*},$$
or equivalently for every $\a^*$ the vector $\q^{\Pi}\of{\a^*}:=(q^{\Pi}_y\of{\a^*})_{y\in\Y}$ belongs to the \emph{convex-hull} of the rows of $M_f$.

\paragraph{General functions.}
We now extend the above discussion to non-Boolean functions. For every function $f:\X\times\Y\mapsto\Z$. For every $z\in\Z$ we associate with $f$ a matrix $M_f^{z}$ defined as $M_f^z\of{x,y}=\pr{f(x,y)=z}$.
\deleted{
$$
M_f^z\of{x,y}=
\begin{cases}
1&\text{ if }f(x,y)=z\\
0&\text{ otherwise}
\end{cases}
$$
}
Similarly to the Boolean case, in the ideal world, every strategy that is employed by a corrupt server can be encoded with a probability vector $\p\in\R^{n}$, hence the probability that the client will output $z$ on input $y$ is $\p^T\cdot M_f^z\of{\cdot,y}$. In the 1-round $\OThybrid$ model, for a string $\myvec{a}^*\in\zo^{2\ell}$ chosen by a malicious server, the probability to output $z$ equals
$$q^{\Pi}_{y,z}\of{\a^*}:=\Pr_{\b=\clnt\of{y}}\left[\local\of{y,\b,\a^*[\b]}=z\right].$$ 
Therefore, perfect simulation is possible if and only for every $\a^*\in\zo^{2\ell}$ there exists a probability vector $\p\in\R^n$ such that for every $y\in\Y$ and for every $z\in\Z$
\begin{align}\label{eq:geomrep}
\p^T\cdot M^z_f\of{\cdot,y}=q^{\Pi}_{y,z}\of{\a^*}.
\end{align}
Observe that since $\p$ is a probability vector and since $\sum_z M_f^z$ is the all-one matrix, it is enough to consider $k-1$ instances of $z$ instead of the $k$ instances written above. Let $M_f=\left[M_f^{1}||\ldots||M_f^{k-1}\right]$ be the concatenation of the matrices by columns. Then \cref{eq:geomrep} is equivalent to saying that for every $\a^*$ the vector $\q^{\Pi}\of{\a^*}:=\left((q^{\Pi}_{y,z}\of{\a^*})_{y\in\Y}\right)_{z\in[k-1]}$ belongs to the \emph{convex-hull} of the rows of $M_f$. It will be convenient to index the columns of $M_f$ with $(y,z)$, \ie we let $M_f\of{x,(y,z)}=M_f^z\of{x,y}$. Equivalently, we can apply the presentation discussed for Boolean functions, to the function $f':\X\times\left(\Y\times[k-1]\right)\mapsto\zo$, defined as $f'(x,(y,z))=1$ if $f(x,y)=z$, and $f'(x,(y,z))=0$ otherwise. We now have an equivalent definition of perfect server security.

\begin{lemma}\label{lem:srvrsec}
Let $\Pi$ be a protocol for computing some function $f:\X\times\Y\mapsto\Z$ in the 1-round $\OThybrid$ model with $\CC$ of $\ell$. Then $\Pi$ has perfect server security if and only if $$\q^{\Pi}\of{\a^*}\in\CH{M_f^T},$$
for every $\a^*\in\zo^{2\ell}$.
\end{lemma}

\deleted{Similarly, we can restate the notion of \emph{strong $\eps$-server security} in geometrical terms.}
% We next describe another for security against a corrupt server. Intuitively, it states that for functionalities that allow the server to ``abort'' in the \emph{ideal-world}, security against a malicious server holds if the simulation error is small relative to the probability that the simulator decides to aborts. 
Intuitively, it states that for a malicious server, the \emph{less} it deviates from the prescribed protocol, the \emph{better} it can be simulated. Moreover, instead of using the traditional $\ell_1$ distance (\ie statistical distance) we phrase the security in terms of the $\ell_\infty$ norm. This, somewhat non-standard, definition will later act as a sufficient condition for reducing perfect server-security to perfect client-security.

\begin{definition}\label{obs-geom-enh-cl}
Let $f:\left(\X\cup\set{\bot}\right)\times\Y\mapsto\set{\bot,0,\ldots,k-1}$. Assume that $f(x,y)=\bot$ if and only if $x=\bot$.	Let $\Pi=\vect{\srvr,\clnt,\local}$ be a protocol for computing $f$ in the 1-round $\OThybrid$ model. We say that $\Pi$ is \emph{strong $\eps$-server secure}\footnote{Although this definition as stated is not actually stronger than the standard server security definition, we decide to keep this name because of the intuition behind it. Furthermore, stating simulation error \wrt the $\ell_1$ norm instead of the $\ell_\infty$ norm, is in fact stronger.} \bnote{Should rename. Its not stronger anymore.} if the following holds. For every message $\a^*$ sent by a malicious server in the $\OThybrid$ world, there exists a probability vector $\p=\vect{p_x}_{x\in(\X\cup\set{\bot})}\in\R^{|\X|+1}$ such that\deleted{for every $y\in\Y$ it holds that
	$$\SD_{\myvec{b}\from\clnt(y)}\of{\local\of{y,\b,\a^*[\b]},~\p^T\cdot M_f\of{\cdot,(y,\cdot)}}\leq \eps\cdot p_\bot,$$
    }
    \deleted{$$\half\cdot\norm{\q^{\Pi}\of{\a^*}- M^T_f\cdot\p}{1}\leq\eps\cdot p_\bot.$$}
    
    $$\norm{\q^{\Pi}\of{\a^*}- M^T_f\cdot\p}{\infty}\leq\eps\cdot p_\bot.$$
    
	\deleted{where $M_f\of{\cdot,(y,\cdot)}=\vect{M_f^z\of{\cdot,y}}_{z\in\Z}$.}%\footnote{This is not exactly equivalent to enhanced $\eps$-client correctness, as the parameters here are slightly worse, but this is all we need, and it simplifies the definition.}
\end{definition} 

\subsection{Stating The Main Result}
With the above representation in mind, we are now ready to state our main result. We first recall the definition of a full-dimensional function, as stated in \cite{Ash14}.

\begin{definition}[full-dimensional function]
We say that a function $f:\X\times\Y\mapsto\Z$ is \emph{full-dimensional} if $$\operatorname{dim}\of{\aff{M_f^T}}=(k-1)\cdot|\Y|,$$
namely, the affine-hull defined by the rows of $M_f$ spans the entire vector space.
\end{definition}

\begin{theorem}\label{thm:main}
Let $f:\X\times\Y\mapsto\Z$ be a full-dimensional function. Then there exists a protocol $\Pi$ in the 1-round $\OThybrid$ model, that computes $f$ with perfect full-security. Furthermore, the $\CC$ is the following. Let $\gamma_i$ denote the size of the smallest formula for evaluating the $i$'th bit of $f(x,y)$, and let $\gamma=\max_{i} \gamma_i$. Moreover, if $f$ is deterministic, then $\Pi$ has $\CC$ at most
\anote{No need for the log factors, there are consumed by the $poly(k,|Y|)$ factors}
$$\ell\leq O\of{\gamma^2\cdot\log k\cdot \log|\Y| \cdot\poly\Big(k\cdot|\Y|\Big)}
.$$
\bnote{$\gamma$ is defined for the PRE of $g'$ defined in \cref{sec:IKOPS}.}
\end{theorem}

Recall that a basis for an affine space of dimension $n$ has cardinality $n + 1$, and therefore we must have that $|\X|>(k-1)\cdot|\Y|$. Thus, we assume without loss of generality that this holds.
A simple corollary of \cref{thm:main} is that adding constant columns to a full-dimensional function, results in a functions that can still be computed with perfect security.

\begin{corollary}\label{cor:main}
Let $f:\X\times\Y\mapsto\Z$ be some function. Assume that there exists a subset $\Y'\su\Y$ that fixes the output distribution of $f$, \ie for all $y\in\Y'$ there exists a distribution $D$ over $\Z$ such that $f(x,y)\equiv D$ for every $x\in\X$. Then if the function $f':\X\times(\Y\setminus\Y')\mapsto\Z$, defined as $f'\of{x,y}=f(x,y)$, is full-dimensional, then $f$ can be computed the 1-round $\OThybrid$ model with perfect full-security and with the same communication complexity.
\end{corollary}
\ifdefined\IsFV
\begin{proof}
Let $\Pi$ be the protocol for $f'$ guaranteed by \cref{thm:main}. Then the parties computes $f$ as follows. $\Sc$ act the same as in $\Pi$. If the input of $\Cc$ is $y\in\Y'$, then $\Cc$ output $f(x_0,y)$ for some arbitrary $x_0\in\X$, and if its input is $y\notin\Y'$, then act the same as in $\Pi$.
\end{proof}
\else\fi

Many interesting examples of functionalities that satisfy the constraints in \cref{thm:main,cor:main} exists.
\ifdefined\IsFV
The following are two example for such functionalities, who where taken from \cite{Ash14}.
\begin{description}
	\item[Set membership:] The server holds a subset $\S$ of some finite universe $\Omega$, and the client holds an element $\omega\in\Omega$. The client wishes to know if $\omega\in\S$. The matrix for this function contains all possible Boolean vectors of length $|\Omega|$, hence the function is full-dimensional.
    
    \item[Set disjointness:] Although for this functionality $|\X|=|\Y|$, it satisfies the constrains in \cref{cor:main}. Here, the server and client each holds a set $\S,\T\su\Omega$ respectively, and the client's output should be whether or not $\S\cap\T=\emptyset$. Observe that $\T=\emptyset$ is the all-one column, and that after removing it, the function that remains is full-dimensional, and hence can be computed.
\end{description}
\else
The following is an example for such a functionality. This was taken from \cite{Ash14}. Consider the \emph{Set membership} task. The server holds a subset $\S$ of some finite universe $\Omega$, and the client holds an element $\omega\in\Omega$. The client wishes to know if $\omega\in\S$. The matrix for this function contains all possible Boolean vectors of length $|\Omega|$, hence the function is full-dimensional.
\fi

\cref{thm:main} clearly follows from the following two lemmata. The first lemma states that given a protocol that computes a related function $g$ with perfect client security and strong statistical server security, we can construct a perfectly secure protocol for $f$. The second lemma states that such a protocol for $g$ exists.

\begin{lemma}\label{lem:geom}
Let $f:\X\times\Y\mapsto\Z$. Define the function $g:(\X\cup\set{\bot})\times\Y\mapsto\set{\bot,0,\ldots,k-1}$ as $g(x,y)=f(x,y)$ if $x\ne\bot$ and $g(\bot,y)=\bot$. Assume that for every $\eps>0$, there exists a protocol $\Pi_g$ in the 1-round $\OThybrid$ model that computes $g$ with correctness, has strong $\eps$-server security, has perfect client security, and has $\CC$ of $\ell\of{\eps,|\X|,|\Y|,k}$. Then, if $f$ is full-dimensional, there exists a protocol $\Pi_f$ in the 1-round $\OThybrid$ model, that computes $f$ and has perfect full-security. Moreover, if $f$ is deterministic then $\Pi_f$ has $\CC$ at most
$$\ell\of{\frac{1}{2n(n+1)!},~|\X|,~|\Y|,~k},$$
\bnote{$\alpha$ is defined for the PRE of $g'$ defined in \cref{sec:IKOPS}.}
where $n=(k-1)\cdot|\Y|$.
\end{lemma}

\begin{lemma}\label{lem:COT}
Let $g:(\X\cup\set{\bot})\times\Y\mapsto\set{\bot,0,\ldots,k-1}$ be a function such that $g(x,y)=\bot$ if and only if $x=\bot$. Then for every $\eps>0$ there exists a protocol $\Pi_g$ in the 1-round $\OThybrid$ model that computes $g$ with correctness, has strong $\eps$-server security, has perfect client security. Furthermore, the $\CC$ is the following. Let $\gamma_i$ denote the size of the smallest formula for evaluating the $i$'th bit of $g(x,y)$, and let $\gamma=\max_{i} \gamma_i$. Then $\Pi_g$ has $\CC$ of
    $$\ell\leq O\of{\gamma^2\cdot\log k\cdot\log|\Y|\cdot\polylog\of{\eps^{-1}}}.$$
    \TODO{Verify.}
\end{lemma}

We prove \cref{lem:geom} in \cref{sec:geom} and we prove \cref{lem:COT} in \cref{sec:IKOPS}.
\anote{We need to say a few words on how Theorem 3 follows from these lemmas. In particular, we need to say which $g$ we are using for evaluating a given $f$.}

% \section{Our model}
% We consider secure evaluation of client-server (non interactive, deterministic) functionalities $f:X\times Y\rightarrow Z$ for finite domains $X,Y,Z$, where the client outputs $f(x,y)$ and the server outputs $\bot$ (has no output).\footnote{All the definitions below readily generalize to randomized functionalities $f$, but we focus on deterministic $f$ for simplicity.} 
% We focus on finite functionalities $f$ (that is $X,Y,Z$ are finite, and independent of a security parameters $k$).

% We consider secure evaluation of such $f$ in the stand-alone setting, with unconditional security, against a non adaptive malicious adversary corrupting a single party.
% We work in an ``enhanced'' version of the $\OThybrid$ model where in every round a party either sends information over the point-to-point channel, or the parties make a call to a perfectly secure implementation of ${\bOT{1}{2}}^l$ for some number $l$ that may depend on the round number (the client plays the receiver's role in all the oracle calls), which is rather standard. We assume the order of speaking is fixed, and does not depend on the communication so far, the inputs, or the randomness.
% \footnote{The point-to-point channel is not necessary in 1-round protocols where the client does not send messages to the server, as any messages sent to the client over this channel can be emulated by the OT channel.} 
% For client and server inputs $c\in\{0,1\}^l$, $s=((s_{1,1},s_{1,2}),\ldots,(s_{l,1},s_{l,1}))$ to ${\bOT{1}{2}}^l$, respectively, we let $s[c]$ denote $s_{1,c_1},\ldots,s_{l,c_l}$.

% Our security notion is the standard simulation-based notion as in~\cite{Can00}.
% That is, we require statistical security against a malicious server or a malicious client, and perfect correctness if both parties behave honestly.
% We say a protocol is $\epsilon(k)$-client correct if for any malicious server the simulation error is bounded from above by $\epsilon$.

% More specifically, fix a 2PC protocol in the $\OThybrid$ model, where the parties are dubbed ``client'' and ``server'' respectively.
% For any (non-uniform) adversary $A$ corrupting the server in $\Pi$, and $x\in X,z\in \{0,1\}^*$ define
% $Real^{\Pi,z,x}_A=(OUT_A(1^k,z)(x),View_A(1^k,z)(z))$
% For an ideal-world adversary $S$ controlling the server let 
% $Ideal^{\Pi,z,x}_S=(OUT_S(1^k,z)(x),View_S(1^k,z)(z))$
% We require that for any adversary $A$ there exists a simulator 
% $S_A$ such that for all $x,z$ 
% \[SD(Ideal^{\Pi,z,x}_S,Real^{\Pi,z,x}_A)=neg(k).\]
% Here the ideal-world adversary may not abort the computation (that is, we require full security).
% Additionally, if $A$ is polynomial-time, then so is $S_A$.
% The definition for security against a corrupted client is analogous.

% %	We consider standard efficient protocols with efficient simulation against PPT adversaries. The statistically (not perfectly) secure protocols we use as building blocks for our perfect constructions are in fact secure against unbounded adversaries with efficient simulation.
% We say that the protocol is $\epsilon(k)$ server-private if the simulation error against every malicious client is bounded by $\epsilon(k)$.

% For simplicity, we do not concern ourselves with the efficiency 
% of protocols or the simulator, and allow all parties to be unbounded.
% The adversaries we allow are also unbounded.
% In fact, our simulator can be made efficient for efficient (in $k$) adversaries, but this is a secondary issue, and is deferred to the full version.

% If the simulator's output joint with honest party's output
% corresponding to (every) malicious adversary (server or client respectively) has distance $\leq \epsilon$ from the real world distributions, we say the protocol is $\epsilon$-statistically secure. The protocol is statistically secure if $\epsilon(k)$ is negligible in $k$. If $\epsilon$ equals 0 for all adversaries, we say the protocol is perfectly secure against a malicious server (client).
% %For simplicity, we deviate from the standard MPC model by removing the requirement of the parties and the simulator are efficient (in the security parameter).\footnote{This is only useful for non-perfect protocols, perfect protocols for finite functionalities as we consider are automatically efficient.} 

% \paragraph{1-round protocols.}

% In this work we further focus on 1-round protocols, where a single call to ${\bOT{1}{2}}^l$ is made by the parties.
% In this setting, security against malicious senders reduces to requiring that the 
% client's output distribution alone is consistent with some input distribution $x^*$ over $X$, as the sender has no view and no output.
% For corrupted clients, we again consider only their view alone, as the sender has no output. 
% %\footnote{As we consider perfect protocols and finite functionalities, there is no issue of efficiently finding $x^*$.}

% \begin{definition}[1-round protocols in $\OThybrid$ model]\label{def-prot}
% 	A protocol for evaluating $f:X\times Y\rightarrow Z$ are tuples $\Pi=(\Pi_Q,\Pi_R,\Pi_D)$ of randomized algorithms, where $\Pi_Q(x):X\rightarrow \{0,1\}^l$ generates client's query $c$. $\Pi_R(x,c,v):X\times\{0,1\}^l\times  \{0,1\}^l\rightarrow Z$ generates client's output based on $x,c$ and OT reply $v$.\footnote{For some, but not all functions $f$, $x$ is not required as an input to $R$, as $C_x\cup C_{x'}=\phi$ for all $x\neq x'$. It is not hard to prove that a sufficient condition on $f$ for having $C_x\cup C_{x'}=\phi$ in all secure protocols for $f$ is the existence of a $2\times 2$ rectangle $\{y,y'\}\times\{x,x'\}$ in which 3 of the entries are identical, and the other entry differs from these three.} $\Pi_D(y):Y\rightarrow \{0,1\}^{2l}$ is server's generator of OT inputs. We refer to $l$ as the communication complexity of $\Pi$.
% \end{definition}

% %For $s=(s_{1,0},s_{1,1},\ldots,s_{l,0},s_{l,1})\in\{0,1\}^{2l}$,
% %and $c\in\{0,1\}^l$, we let $s[c]$ denote $(s_{1,c_1},\ldots,s_{l,c_l})$.
% %For a vector $c\in \{0,1,\bot\}^l$ $s[c]$ is defined as above, but if $c_i=\bot$ the $i$'th entry in $s[c]$ equals $\bot$.


% A protocol $\Pi=(\Pi_Q,\Pi_R,\Pi_D)$ as in Definition~\ref{def-prot} with CC $l$ operates in the ${\bOT{1}{2}}^l$-hybrid model as described above.\footnote{In particular, it first receives all inputs and only then returns all the outputs to the client. No rushing such as sending inputs to a certain OT instance after getting outputs from other OT instances is possible.}
% That is, it is specified by a pair of randomized Turing machines $\Pi^?_C,\Pi^?_S$ with oracle access to an idealized functionality ${\bOT{1}{2}}^l$ operating as follows
% \begin{enumerate}
% 	\item[$\Pi^?_C(x;r):$] 
% 	Let $c=\Pi_Q(x;r)$. Send $c$ as input to the ${\bOT{1}{2}}^l$ oracle, and let $v$ denote the oracle's output. Output $\Pi_R(x,c,v;r)$.
% 	\item[$\Pi^?(y;r):$] Let $s=\Pi_D(y;r)$, and send it to the 
% 	${\bOT{1}{2}}^l$ oracle.  
% \end{enumerate}
% Both algorithms $\Pi_C,\Pi_S$ run in parallel, in a single round.
% We will usually use the notation $\Pi=(\Pi_Q,\Pi_R,\Pi_D)$ to denote protocols, while $\Pi_C,\Pi_S$ are implicit.

% The above definition defines the syntax of protocols we consider. In the following (this and following section) we discuss the security requirements we pose on our protocols.

% We will usually state our protocols in a hybrid model where the parties have access to some $l$ oracles $\sOT{1}{t_i}{h_i}$ in parallel, where $l$ and $(t_i,h_i)$ are numbers of our choice. 
% This is potentially useful for optimizing the complexity of real-world, computationally secure protocols that are based on our construction, as OT extension allows to implement $\sOT{1}{2}{h}$ using a sublinear (in $k$) number of calls to $\bOT{1}{2}$ and some additional sublinear work, assuming a strong variant of PRG~\cite{IKOS08}. 
% Also, this is wlog. in our perfectly secure setting and costs only linear time $O(tk)$ to convert into a perfect protocol in the $\bOT{1}{2}$-hybrid model by using the 1-round perfect reduction from Theorem~\ref{thm-int}.

% From now on, all out definitions apply to 1-round protocols for client-server functionalities (in the OT hybrid), as we only consider this type of protocols. 

% \begin{definition}\label{def-enh-cl}
% Here, we assume that $f$ is defined on $f:X\times Y \rightarrow Z$,  where $\bot\in Y,Z$ and $f(x,y)=\bot$ iff. $x=\bot$.	
% We say a protocol $\Pi$ as in Definition~\ref{def-prot} evaluates $f$ with  $\epsilon$-enhanced client correctness if it satisfies the same definition as $\epsilon$-client correctness, with the following additional guarantee.
% For any (deterministic) server strategy $S^*$, there exists a distribution $Y^*$ over $Y$ such that for all $x$,
% \[\Delta(\Pi_R(x,c\leftarrow \Pi_Q(x),S^*[c]), f(x,Y^*))\leq \epsilon p_{\bot}\] where $p_\bot=Pr_{Y^*}(\bot)$. \footnote{This enhances the $\epsilon$-client correctness requiring only a distance bound 
% of $\epsilon$, rather than $\epsilon p_\bot$.} 
% \end{definition}

% The second notion is a relaxation of perfect client correctness.\footnote{This is a relaxation as it allows for conditional abort. It also strengthens the definition in the sense that every deterministic server strategy induces a single effective input $y$, rather than a distribution.}

% \begin{definition}
% Here we assume $\bot\in Y$.	
% In the model with input-value client-security, we modify the ideal model to allow the simulator send a single value $y^*\in Y$ to the TP.	
% It also gives the TP a predicate $P$ such that the TP sends the client $f(x,y)$ if $P(x)=0$, and $f(x,\bot)$ otherwise.	
% We say a protocol $\Pi$ as in Definition~\ref{def-prot} evaluates $f$
% with perfect input-value security, if for any adversary ,there exists a simulator with simulation error of 0.
% \end{definition}

% \subsection{Restating security requirements geometrically.}

% We take a similar approach to that of~\cite{Ash14} 
% to representing (some of the) protocols' security requirements geometrically.
% %More specifically, we represent the client's output distributions vector for a given server's strategy as a vector over $\R^t$ for a suitable $t$. This vector bundles together client output dsitributions for all client's inputs, with a subset of coordinates corresponding to each client's input. A protocol $\Pi$ defines a region $P_S$ of achievable distributions corresponding to all possible (possibly malicious) server strategies.

% %Similarly, for a given client's strategy, we consider the client's vector of \emph{views}, with a subset of coordinates corresponding to each server's input $y$.  Similarly to $P_S$, $\Pi$ defines a region $P_C$ of achievable distributions corresponding to all client's strategies. 

% More specifically, for client correctness, we consider row distribution vectors achievable 
% in the ideal model. That is, the region $\tilde{P}_S$ denotes all achievable row distributions corresponding to possible ideal-world server strategies.
% This region simply corresponds to the convex hall of the rows of $f$'s 
% truth table $F$.

% %Jumping ahead, our representation of distributions will be such that the region $\tilde{P}_S$ will roughly correspond to convex combinations of row and column vectors of the function's truth table.

% To achieve security against a malicious server, we require that
% the region of real-world achievable row distributions $P_S$ satisfies
% $P_S\subseteq \tilde{P}_S$.
% Properties 2,3 in the security definition are verified directly.
% %For honest correctness (that is, the protocol always outputs the correct value if both parties behave honesly), we make a separate requirement on distribution vectors corresponding to valid client and server strategies. %While the first two requirements are readily expressed as a single LP (linear program)~\cite{}, it is unclear how to incorporate the third requirement into the same program. 


% \paragraph{Geometric representation of client's output distributions.}
% Fix a protocol $\Pi=(\Pi_Q,\Pi_R,\Pi_D)$
% as in Definition~\ref{def-prot} for evaluating a functionality $f:X\times Y\rightarrow Z$. For the sake of defining our output distributions we view the protocol as merely randomized mapping from $X\times Y$ to client outputs $Z$, and do not require it to securely evaluate $f$, or even correctly evaluate it if everyone behaves honestly.

% \paragraph{Boolean functions.} Fix $Z=\{0,1\}$. For a given server's strategy $\Pi^*_D(x=y;r)=s^*$ for some fixed $s^*\in\{0,1\}^{2l}$\footnote{This notion naturally generalizes to randomized strategies, but we do not need this extent of generality here.}, 3we consider the distributions of the client's output at the end of a protocol execution $\Pi^*=(\Pi_Q,\Pi_R,\Pi^*_D)$ (that is, a protocol resulting from $\Pi$ when the server runs $\Pi^*_D$ instead of $\Pi_D$). We denote this set of distributions
% by a vector $o\in \R^{|X|}$ indexed by $x\in [|X|]$. Here $o_x=p$ denotes the probability of the client outputting $1$ on input $x$
% That is,
% \[o_x = Pr_r[\Pi_Q(x;r)=c;\Pi_R(x,c,s^*[c])=1].\]

% We refer to such a vector corresponding to some (possibly invalid) server's strategy $s^*$ as a \emph{geometric row distribution} for $\Pi$. 
% We shall also consider geometric row distributions for the ideal model evaluating $f$, corresponding to server's input distributions $y\in Y$, referring to them as a row distribution for $f$. We omit $\Pi,f$ whenever clear from the context.

% Observe that the single number $o_x$ uniquely encodes a distribution over the client's output set $\{0,1\}$ on input $x$.\footnote{The vector $o$ represents $|X|$ separate distributions, one for each client's input $x$. Nothing is implied about the correlation between client's outputs on different inputs for a given server's strategy $s^*$.} Similarly, we consider \emph{geometric column distributions} for $\Pi$: for a given client's strategy $c^*\in\{0,1\}^l$ for its input to the OT oracle, we consider the corresponding \emph{geometric column} distribution vector $o\in \{0,1\}^{|Y|}$ indexed by  $y\in [|Y|]$, where $o_y$ is the probability of the client outputting $1$ for server input $y$. That is:
% \[o_y = Pr_r[\Pi_R(x,c^*,\Pi_D(y;r)[c^*])=1].\]

% \paragraph{General functions.} Generalizing for larger $Z=\{0,1,\ldots,k-1\}$, a (geometric) row distribution $o\in \mathbb{R}^{(k-1-1)|X|}$, has entries labeled by
% pairs $(x,i)$ where $x\in [|X|],i\in Z\setminus{\{0\}}$, and $o_{(x,i)}$ denotes the probability of outputting $i$ on input $x$. Thus, for every $x,i$ we have $\sum_j o_{(x,j)}\leq 1$, and $o_{(x,i)}\geq 0$.\footnote{The decision to exclude 0 is merely aesthetic, intended to remain consistent with standard binary truth tables.}
% As in the case of $|Z|=2$, this vector fully represents the client's output distribution for each input $x$. A similar extension can be made for (geometric) row distributions. For a given $x\in X$, let $o_x$ denote the sub-vector $(o_{x,z})_{z\in [k-1]}$.
% %Also, the notion naturally extends to secure computation of randomized client-server functionalities $f:X\times Y\rightarrow Z$. Here exactly the same notions of client output distributions apply.

% \paragraph{Truth tables.} In the truth table $F$ of $f$, we index rows by elements of $Y$ and columns by elements of $X$. For $Z=\{0,1\}$, the truth table representation we consider is just the standard one: a table where entry $(y,x)$ equals $f(x,y)$. We use $F_y$ to denote the row vector ($X_x$ to denote the column) in $F$ corresponding to $y$ ($x$).
% We observe that each row $F_y$ in this case is a geometric row distribution in the ideal model, where the server inputs $y$. We can interpret $Y_{y,x}$ as $f(x,y) = p$, where $p$ is the probability of outputting $1$ (either $p=0$ or $p=1$). 


% Let us generalize this form to larger $Z$. We represent the truth table in "unary", where for each $y,x$ we have $|Z|-1$ columns $(x,z)_{z\in [|Z|-1]}$, and we set $F((x,z),y)=1$
% if $f(x,y)=z$, and $F((x,z),y)=0$ otherwise (if $f(x,y)=0$, all entires $F((x,z),y)$) will be $0$).\footnote{This is instead of having a single entry for each $(x,y)$ with values in $Z$.}
% Again, each row $F_y$ is a valid geometric row distribution in the ideal world (corresponding to a server input of $y$).

% \begin{definition}[~\cite{Ash14}]
% 	We say a function $f:X\times Y\rightarrow Z$ is full-dimensional if the affine dimension of the row set of its truth table $F$ is the maximal possible - $(|Z|-1)|X|$.
% \end{definition}

% \paragraph{Definition of security.}
% As mentioned above, for client-server functionalities, the standard requirement of perfect stand-alone security in the ${\bOT{1}{2}}^l$-hybrid model can be restated as three separate requirements, all involving only the client's output distribution.
% %Let us recall the standard definitions of security against malicious parties in the ${\bOT{1}{2}}^l$-hybrid model.
% %\begin{definition}
% %Let $\Pi$ denote a protocol for evaluating a function $f$ as in %Defintion~\ref{def-prot} in the ${\bOT{1}{2}}^l$-hybrid model. Then it evaluates $f$ with malicoius security against a non adaptive malicious adversary if it satisfies:
% %\begin{itemize}
% %	\item[Security against malicious servers:]
% %	For all algorithms $\Pi^*_D(y;r)$, there exists a randomized simulator algorithm $Sim^*_D(y;r):Y\rightarrow Y$ such that for all $x\in X,y\in Y,r_s$, the following equality of distributions holds.
% %	\[\Pi_R(x,\Pi_Q(x;r_c),\Pi_D(y;r_s))=f(x,Sim^*_D(y;r_s))\]
% %	\footnote{Wlog. we may assume $\Pi^*_D$ is deterministic. Also note that we do not require that the algorithms (as we generally consider finite functionalities). Due to the simple structure of $\Pi$ the above requirement can be further simplified to requiring that for all $.$ there exists a distribution $Y^*$ over $Y$ such that 
% %	\[\Pi_R(x,\Pi_Q(x;r_c),s^*)=f(x,Y^*)\].}
% %\end{itemize}
% %\end{definition}
% %\atodo{Is this defintion acceptable, or should I use the standard definition, with auxiliarry input $z$ and efficient simulation?}
% For such functionalities and protocols $\Pi$ as in Definition~\ref{def-prot} the standard definition of perfect security against malicious parties is ``almost'' equivalent to the following definition.
% It would be fully equivalent if it required simulation of efficient (in $k$) adversaries is also efficient. Our protocols in fact satisfy the stronger definition, as we prove in the full version. We ignore efficiency issues altogether in this work for the sake of simplicity. 

% For simplicity, our security definition is stated without account for auxiliary information $z$ that the adversary and simulator receive regarding the other party's input, required for sequential composition. It is easy to see that it in fact follows from our definition below. 

% In our security definition, security against malicious servers is stated in geometrical terms, which will be useful for use later.
% %In particular (in both direction), we take advantage of the fact that the server recieves no messages, and that the parties are unbounded, and consider only the client's view/output respectively. 

% \begin{definition}[Perfect security of protocols as in Definition~\ref{def-prot}]\label{perfect-security}
% We say that a protocol $\Pi$ as in Definition~\ref{def-prot} for evaluating a client-server functionality $f:X\times Y\rightarrow Z$ as above is perfectly secure against a single malicious party if it satisfies:
% \begin{enumerate}
% \item Client correctness: For every server's strategy $s^*\in \{0,1\}^{2l}$, the corresponding row distribution $o^*$ of $f'$
% is in $\CH{\{F_y\}_{y\in Y}}$, where the $F_y$'s are the rows of the truth table $F$ of $f$.
% \item Server privacy: For every client strategy $c^*$, there exists a simulator $S$ such that for all $y$,
% $S(1^k)$ is distributed identically to $\Pi_D(y)$. 

% \item Honest correctness: Let $C_x=\support(\Pi_Q(x)),S_y=\support(\Pi_D(y))$. Then for all $c\in C_x,s\in S_y$, $\Pi_R(x,c,s[c])=f(x,y)$.
% \end{enumerate}
% \end{definition}

% Next we restate Definition~\ref{def-enh-cl} in geometrical terms.

% \begin{observation}\label{obs-geom-enh-cl}
% 	Consider a protocol $\Pi$ evaluating a function $f$ as in Definition~\ref{def-enh-cl} with $\epsilon$-enhanced client correctness.
% 	Then the following holds. 
% 	For every server's strategy $s^*\in \{0,1\}^{2l}$, 
% 	there exists an ideal world row distribution $o^*\in \CH{\{F_y\}_{y\in Y}}$ such that 
% 	the real world row distribution $o'$ corresponding to $s^*$
% 	satisfies 
% 	\[\Delta(o',o^*)\leq \epsilon(|Z|-1)p_\bot\]
% 	Here $p_\bot$ is the coefficient of $Y_\bot$ in $o^*$.\footnote{This is not exactly equivalent to enhanced $\epsilon$-client correctness, as the parameters here are slightly worse, but this is all we need, and it simplifies the definition.}
% \end{observation} 
\deleted{
\section{A Special Case $\X=\{0,1\}$}\bnote{This is not a warmup. Its just a trivial observation. I think we should state in the main result that we assume the server has at least 3 inputs, and the case for 2 inputs will be in the appendix}

As a warmup, we observe that for all finite $Z$
all client-server functions $f:X\times Y\rightarrow Z$ where $Y=\{0,1\}$
have a perfectly secure protocol in the OT hybrid model. In turn, this is a special case of a folklore construction for $f$'s where $F$ has a column $x_0$ that \emph{dominates} all other columns (recall that a column $x$ dominates a column $x'$ if for all $y\in Y$ $F(x,y)=F(x,y')$ implies that  $F(x',y)=F(x',y)$.). 
The protocol in fact does not use OT oracle, and is secure in the plain model.\footnote{The protocol is 1-round, and in particular can be replaced by one as in Definition~\ref{def-prot}, since sending a message in $|Z|$ over a channel can be implemented via a call to $\bOT{1}{2}{\log{|Z|}}$ where the message to be sent is placed in both positions.}

This trivial (set of) examples is the only type of functions we know of that is not fully covered by our main construction~\ref{thm-main}. 

\begin{theorem}
	Let $f:X\times Y\rightarrow Z$ be a client server functionality where $F$ has a column $x_0$ that dominates all other columns. Then there exists a 1-round perfectly secure protocol for $f$ in the plain model.
\end{theorem}

\paragraph{Proof Sketch.} Consider the following protocol.
If all columns in $F$ are constant, the client just outputs $f(x_0,y_1)$ where $y_1\in Y$ is fixed arbitrarily without any communication. Otherwise, the server simply sends $o=f(x_0,y)$ to the client.
The client recovers $f(x,y)$ from $o$: as column $F^{x_0}$ dominates 
column $F^x$, $f(x,y)$ is uniquely determined by $o$.

The construction is private against malicious clients, as the client's view can be simulated by sending $x_0$ to the trusted party, where $x_0$ is an entry such that column $x_0$ in $F$ has two distinct entries.

A malicious server's behavior can also be simulated, as it sends a message distributed over $\{f(x_0,y)\}_{y\in Y}$ according to some distribution (anything outside $Y$ is interpreted as some default value). \hspace*{385pt}$\blacksquare$ 


\begin{corollary}
	Let $f:X\times Y\rightarrow Z$ be a client server functionality where $Y=\{0,1\}$. Then there exists a 1-round perfectly secure protocol in the plain model.
\end{corollary}

%First observe that wlog. we may assume $Z=\{0,1\}$, as for each input $x$ we only need two labels for $f(x,y)$.\footnote{In general, we may assume $|Z|\leq |Y|$.}
}

%\section{A Perfect Protocol for Full-Dimensional Functions}
% Due to the simple structure of 1-round protocols in the OT hybrid model,
% the first two security requirements are fully expressed as a single LP (linear program)~\cite{Kan39, Dantzig60} specifying $(\Pi_Q,\Pi_D,\Pi_R)$. However, it is unclear how to incorporate the third requirement into the same program. Thus, we do not write an explicit LP searching for a specification of $(\Pi_Q,\Pi_D,\Pi_R)$.
% The resulting LP is not trivial to solve even for requirements 1,2 alone in~\ref{perfect-security}. 
% Instead, we take a similar road to that used in the fairness literature, which considers protocols with more general structure. We suggest a concrete protocol, and prove it is secure for a certain subclass of functions. \bnote{This paragraph seems redundant. Why do you explain an approach that does not work and does not have way to ``fix''?}

% For every such function, we separately verify that each of conditions 1,2,3 in Definition~\ref{def-prot}. \bnote{What are conditions 1,2, and 3? They don't appear in the definition.}
% As in the fairness literature, we do use techniques related to solving LP's (analyzing the convex hall of a certain point set) only for proving condition 1 is satisfied by our protocol, but not for searching for a protocol. \bnote{I don't understand. The fairness literature does not use LP for proving stuff. They just build a system of linear equations and solve them.}

\section{Proof of \texorpdfstring{\cref{lem:geom}}{Lemma 2}}\label{sec:geom}
In this section, we reduce the problem of constructing perfectly secure protocol, to the problem of constructing a protocol that has perfect client security and has strong statistical server security. The idea is to wrap the protocol for computing $g$. Whenever the output is $\bot$, the client will output according to a distribution that is consistent with some point that is \emph{strictly inside} the convex-hull of the rows of $M_f$ (\eg the center).
\ifdefined\IsFV
We then show that, with a certain probability, the vector of outputs is distributed according a ``correct'' output distribution, namely according to a distribution consistent with the rows of $M_f$, and with the complement probability, it lies somewhere inside a small hypercube located around the center. Therefore the final vector of outputs is inside some hypercube, that around some point inside the convex-hull. The size of the hypercube is proportional to the security of $\Pi_g$, hence by choosing a small enough $\eps$, the entire hypercube is also inside the convex-hull, completing the proof. We next formalize this intuition.
\else\fi

\begin{proofof}{\cref{lem:geom}}
It is easy to that if the probability that the output of $\Pi_g$ equals $\bot$ is 0 for every $y\in\Y$, then $\Pi_g$ computes $f$ with perfect security.

Assume otherwise. Let $n=(k-1)\cdot|\Y|$. Since $f$ is full-dimensional there exists a subset $\S=\set{\x_1,\ldots,\x_{n+1}}\su\R^{n}$ of the rows of $M_f$, that is affinely independent. Let $\myvec{u}_\S\in\R^{n}$ be the uniform distribution over $\S$ (\ie $u_i=1/|\S|$ if $i\in\S$ and $u_i=0$ otherwise), and let $\c=\vect{c_{y,z}}_{y\in\Y,z\in[k-1]}:=M^T_f\cdot\myvec{u}_{\S}$ be the center of the simplex\footnote{A simplex is the convex-hull of an affinely independent set of points.} that is defined by the points in $\S$. The protocol $\Pi_f$ is described as follows. 

\begin{protocol}[$\Pi_f$]~

Input: Server $\Sc$ has input $x\in\X$ and client $\Cc$ has input $y\in\Y$.

\begin{enumerate}
	\item The parties execute protocol $\Pi_g\of{\eps}$ with small enough $\eps>0$ to be determined by the analysis. Let $z$ be the output $\Cc$ receive.

	\item If $z\ne\bot$, then $\Cc$ output $z$. Otherwise, output $z'$ with probability $c_{y,z'}$.
\end{enumerate}
\end{protocol}

Correctness and perfect client-security follows from the fact that $\Pi_g$ satisfies these properties. We next show that perfect server-security holds. By \cref{lem:srvrsec} it suffices to show that for every $\a^*\in\zo^{2\ell}$ sent to the OT by a malicious server, it holds that
\begin{align}\label{eq:inconv}
\q^{\Pi_f}\of{\a^*}\in\CH{M_f^T}.
\end{align}
For brevity, we write $\q^f$ and $\q^g$ instead of $\q^{\Pi_f}\of{\a^*}$ and $\q^{\Pi_g}\of{\a^*}$ respectively. Since $\Pi_g$ is strong $\eps$-server secure, it follows that there exists a probability vector $\p^g\in\R^{|\X|+1}$ such that
$$\q^{g}=M_g^T\cdot\p^g+\errvec,$$
where $\errvec\in\R^{k\cdot|\Y|}$ satisfies $\norm{\errvec}{\infty}\leq\eps\cdot p^g_\bot$. Let $\bar{\p}^g=\vect{p_x^g}_{x\in\X}$ be the vector $\p$ with $p_\bot$ removed. We first show that \cref{eq:inconv} follows from the following two claims.
\begin{claim}\label{clm:first}
There exists a vector $\widehat{\errvec}\in\R^{k\cdot|\Y|}$ with $\norm{\widehat{\errvec}}{\infty}\leq 2\eps$ such that 
$$\q^f=M_f^T\cdot\bar{\p}^g+p_\bot\cdot(\c+\widehat{\errvec}).$$
\end{claim}

\begin{claim}\label{clm:second}
There exists a small enough $\eps>0$ such that $$\c+\widehat{\errvec}\in\CH{M^T_f}.$$
\end{claim}
Indeed, if 
$$\q^f=M_f^T\cdot\bar{\p}^g+p_\bot\cdot(\c+\widehat{\errvec})$$
and $\c+\widehat{\errvec}\in\CH{M^T_f}$, then there exists a probability vector $\hat{\p}\in\R^{|\X|}$ such that
$$\q^f=M_f^T\cdot(\bar{\p}^g+p_\bot\cdot\hat{\p}).$$
By the definition of $\bar{\p}$ it follows that $\bar{\p}^g+p_\bot\cdot\hat{\p}$ is a probability vector as well, hence \cref{eq:inconv} holds as well.
\end{proofof}

To finish the proof, it is left to prove \cref{clm:first} and \cref{clm:second}.

\begin{proofof}{\cref{clm:first}}
Observe that for every $y\in\Y$ and $z\in[k-1]$ it holds that
\begin{align*}
q^{f}_{y,z}
&=q^{g}_{y,z}+q^{g}_{y,\bot}\cdot c_{y,z}\\
&=M_g^T\of{\cdot,(y,z)}\cdot\p^g+\errval_{y,z}+\left(M_g^T\of{\cdot,(y,\bot)}\cdot\p^g+\errval_{y,\bot}\right)\cdot c_{y,z}\\
&=M_f^T\of{\cdot,(y,z)}\cdot\bar{\p}^g+\errval_{y,z}+(p_\bot+\errval_{y,\bot})\cdot c_{y,z}\\
&=M_f^T\of{\cdot,(y,z)}\cdot\bar{\p}^g+p_\bot\cdot(c_{y,z}+\errval'_{y,z}+\errval'_{y,\bot}\cdot c_{y,z}),
\end{align*}
where $\errvec'=\frac{1}{p_\bot}\cdot\errvec$.
Let $\widehat{\errval}_{y,z}=\errval'_{y,z}+\errval'_{y,\bot}\cdot c_{y,z}$, for all $y\in\Y$ and $z\in[k-1]$.
Then 
$$\q^f=M_f^T\cdot\bar{\p}^g+p_\bot\cdot(\c+\widehat{\errvec}).$$
To conclude the proof, observe that
$$\norm{\widehat{\errvec}}{\infty}\leq\norm{\errvec'}{\infty}\cdot(1+\norm{\c}{\infty})=\frac{1}{p_\bot}\cdot\norm{\errvec}{\infty}\cdot(1+\norm{\c}{\infty})\leq2\eps.$$
\end{proofof}

\begin{proofof}{\cref{clm:second}}
\anote{Made a small modification to this paragrpah. I think it is more precise.}
One approach would be to use similar techniques as in \cite{Ash14}, namely, take a ``small enough'' Euclidean ball around $\c$ and take $\eps$ to be small enough so that $\c+\widehat{\errvec}$ is contained inside the ball. This approach, however, only proves the existence of such an $\eps$. We take a slightly different approach, which also provide an explicit upper bound on $\eps$ for deterministic functions.

%This approach, however, does not give a concrete bound on $\eps$. 
%We show a different proof that will also give a concrete bound on $\eps$, and as a result bound the communication complexity.

For every $i\in[n]$ let $\bar{\x}_i=\x_i-\x_{n+1}$, let $\bar{\S}=\set{\bar{\x}_1,\ldots,\bar{\x}_n}$ be a basis for $\R^n$, and let $A=[\bar{\x}_1||\ldots||\bar{\x}_n]$. Then it holds that
$$\c=M_f^T\cdot\myvec{u}_\S=\sum_{i=1}^{n+1} \frac{1}{n+1}\cdot \x_i=\x_{n+1}+\sum_{i=1}^n \frac{1}{n+1}\cdot\bar{\x}_i=\x_{n+1}+\frac{1}{n+1}\cdot A\cdot\ones_n.$$

Observe that a point is in the convex-hull of $\S$ if and only if it can be written as
$\x_{n+1}+\sum_{i=1}^n p_i\cdot\bar{\x}_i$,
where the $p_i$'s are non-negative real numbers that sum up to \emph{at most} 1. Next, since the set $\bar{\S}$ forms a basis, there exists a vector $\widetilde{\errvec}\in\R^{n}$ such that $\widehat{\errvec}=A\cdot\widetilde{\errvec}$. 
Then if $\norm{\widetilde{\errvec}}{\infty}\leq\frac{1}{n(n+1)}$, it follows that
$$\c+\widehat{\errvec}=\x_{n+1}+A\cdot\left(\frac{1}{n+1}\cdot\ones_n+\widetilde{\errvec}\right)=\x_{n+1}+\sum_{i=1}^n p_i\cdot \bar{\x}_i,$$
where $0\leq p_i\leq 1/n$ for every $i\in[n]$, implying that the point is inside $\CH{\S}$. Thus, it suffices to find $\eps$ for which $\norm{\widetilde{\errvec}}{\infty}$ is small enough. It holds that
\begin{align*}
\norm{\widetilde{\errvec}}{\infty}
&=\norm{A^{-1}\cdot\widehat{\errvec}}{\infty}\\
&=\max_{i\in[n]}\set{\abs{A^{-1}(i,\cdot)\cdot\widehat{\errvec}}}\\
&\leq\max_{i\in[n]}\set{\sum_{j=1}^n\abs{A^{-1}(i,j)\cdot\widehat{\errval}_j}}\\
&=\max_{i\in[n]}\set{\sum_{j=1}^n\abs{\frac{\det{A_{j,i}}}{\det{A}}}\cdot\abs{\widehat{\errval}_j}}\\
&\leq n\cdot\frac{(n-1)!}{|\det{A}|}\cdot 2\eps\\
&=\frac{2n!}{\abs{\det{A}}}\cdot\eps,
\end{align*}
where the third equality is by \cref{fact-cramer}, and the second inequality is due to the fact that each entry in $A$ is a real number between -1 and 1. Therefore, by taking $\eps=\frac{|\det{A}|}{2n(n+1)!}$ the claim will follow. Observe that if the function $f$ is deterministic, then the entries of $A$ of in $\set{-1,1}$ implying that $|\det{A}|\geq 1$, hence we can take $\eps=\frac{1}{2n(n+1)!}$. Therefore the communication complexity will be at most $\ell\of{\frac{1}{2n(n+1)!},~|\X|,~|\Y|,~k}$.

% For $\delta>0$ and a vector $\v\in\R^{(k-1)\cdot|\Y|}$, we let $\B\of{\v,\delta}=\set{\u\in\R^{(k-1)\cdot|\Y|}:\norm{\u-\v}{2}\leq\delta}$, be the Euclidean ball of radius $\delta$ and center $\v$. \citet{Ash14} proved the following claim.
% \begin{claim}[\cite{Ash14}, Claim 4.6]
% There exists a small enough $\delta>0$ such that $\B(\c,\delta)\su\CH{\S}\su\CH{M_f^T}$.
% \end{claim}
% Thus, it is enough to show that we can pick a small enough $\eps>0$ such that $\c+\widehat{\errvec}\in\B(\c,\delta)$. Indeed, by choosing $\hat{\eps}=\delta/\sqrt{k\cdot|\Y|}$, which implies that $\eps=\frac{\delta}{2(1+\norm{\c}{\infty})\cdot\sqrt{k\cdot|\Y|}}$,
% it follows that 
% $\norm{\errvec}{2}\leq\sqrt{k\cdot|\Y|}\cdot\norm{\errvec}{\infty}\leq\delta$, concluding the proof.
\end{proofof}

% In this section we describe the first step of the construction.
% Here we rely on ideas from convex geometry that are somewhat similar to those of~\cite{Ash14}. In particular, the geometric interpretation of $\epsilon$-enhanced client correctness and the following notion of full-dimensional functions is central to our construction.
\deleted{

\begin{lemma}\label{lem-tt-perfect}
	Let $\epsilon>0$, and let $\Pi$ denote a protocol as in Definition~\ref{def-prot} for evaluating $f$ with $\epsilon$-enhanced client security, perfect server privacy, and perfect honest correctness. Then there exists a perfectly secure protocol as in Definition~\ref{def-prot} for evaluating $f$ with communication complexity $\ell(\epsilon,|X|,|Y|)$, where $\ell$ is as in Theorem~\ref{thm-pcl}. 
\end{lemma}

As a corollary from Lemma~\ref{lem-tt-perfect} and Theorem~\ref{thm-pcl}, we obtain our main result.

\begin{theorem}\label{thm-main}
Let $f:X\times Y\rightarrow Z$ denote a full-dimensional function, and
$g=|X|(|Z|-1)$.
Then there exists a protocol $\Pi'$ as in Definition~\ref{def-prot} evaluating $f$ with perfect security against a malicious adversary in the ${\bOT{1}{2}}^l$-hybrid model
for $l=\ell(1/10(g-1)g!, |X|, |Z|)=\tilde{O}(h^2,poly(|X|,|Z|))$, where $\ell$ is the function in Theorem~\ref{thm-pcl}.
 
%$\log(|Z|)\tilde{O}(\log(|X|) (\log({\epsilon^{-1}})+h)^2)+polylog(\epsilon^{-1})=$

Here $poly(|X|,|Z|)$ is a global polynomial, independent of $f$.%\atodo{Calculate what the polynomial's degree is. The polylog factors are more tedious to compute.}

\end{theorem}

\paragraph{Proof sketch.}

We pick a sufficiently small $\epsilon>0$, to be set later, and consider $\Pi^+_{\text{IKOPS}^+,f,\epsilon}$. Fix some vector $v$ in the convex hall of $F$'s (not $F'$'s) rows $F_y$, which is ``far enough from the edges'' of that polygon.
By ``far enough'' we mean that adding up to $\pm\epsilon p_\bot$ in every coordinate
results in a point which is still inside the polygon.
Our protocol $\Pi'$ proceeds as follows. Whenever $\Pi^+_{\text{IKOPS}^+,f,\epsilon}$ outputs $\bot$ as an output on input $x$, output  a distribution consistent with $v_x$. Otherwise, output the value output by $\Pi$. 
Indeed, as $\Pi^+_{\text{IKOPS}^+,f,\epsilon}$ satisfies $\epsilon$-enhanced client correctness, its output distribution 
is of the form.
\begin{equation}\label{eq-1}
o^+ = \sum_i\alpha_i o_i + e_r
\end{equation}
Here $\alpha_i o_i$ is a convex combination of the rows $Y'_i$ of $F'$.
The vector $e_r$ is an error vector, $|e_r|_\infty\leq \epsilon\alpha_\bot$, where $\alpha_\bot$ is the coefficient of $Y_\bot$.\footnote{In fact, for every $x$, $|e_x|_1\leq \epsilon$ , but using this stronger property would not improve our result.}.

Now, as in $\Pi$, an output of $\bot$ on input $x$ is replaced by $v_x$,
$o^+$ in Equation~\ref{eq-1} is replaced by
\begin{equation}
\tilde{o} = \sum_{i\in Y}\alpha_i Y_i + \alpha_\bot (v_x+\tilde{e}_r)
\end{equation}

where $|e_r|_\infty\leq \epsilon$.
It remains to show that $d = v_x + \tilde{e}_r$ is in $\CH{\{Y_y\}_{y\in [|Y|-1]}}$ for the right choice of $v,\epsilon$. This is the case as if $d = \beta_i Y_i$ is a convex combination of $F$'s rows, we get that
\[\tilde{o} = \sum_{i\in Y}\alpha_i Y_i + \alpha_\bot (\beta_i Y_i)=\sum_{i\in Y}(\alpha_i +\alpha_\bot\beta_i)Y_i\]
Since $\alpha_1,\alpha_\bot,\ldots,\alpha_{|Y|}$, and (separately) the $\beta_i$'s are coefficients of a convex combination, thus constituting a valid ideal-world row distribution for $f$.

%Otherwise, the resulting row distribution vector $o_x$ in $\Pi$ is of the form $(1-\epsilon)v+e$, where $|e|_\infty\leq \epsilon$. 
%If $e_{x,\bot}=\alpha_{x,\bot}$, we add $\alpha_{x,\bot}v_x$ to $o'_x$,
%the row distribution vector in $\Pi'$.
%Thus, $o'_x$ is a (syntactically) valid distribution for $f$ \[(1-\epsilon)v+e'\] where $|e'_x|_1\leq \epsilon$ for all $x$ (by a simple calculation, that stems from the fact that $F$ has 0/1 entries, and $v$ has entries in $[0,1]$). In particular, $|e'|_\infty\leq \epsilon$ as well, leaving us inside the convex hall of the $Y_i$'s for sufficiently small $\epsilon$ (since $f$ is full rank). 

It remains to prove that there is a way to pick $v,\epsilon$ 
so that the resulting $\tilde{o}$ satisfies the client correctness requirement.
Since $f$ is full-rank, let us pick  a set of size $g=|X|(|Z|-1)+1$ of rows of $F$, $V = \{Y_1,\ldots,Y_g\}$, such that the dimension of $\{\Delta_{i-1} = Y_i - Y_1\}_{i\geq 2}$ is $g-1$. We will pick $v$ as a convex combination
\[\sum_{i\leq g}\alpha_iY_i\]
of the $Y_i$'s, which we determine in the following.
As $F$ has 0-1 entries we have 
\begin{observation}\label{obs-1}
Each $\Delta_j$ is has entires in the set $\{0,1,-1\}$.
\end{observation}
Let us pick
\[v = 3/4Y_1 + \sum_{2\leq i\leq g}1/4(g-1) Y_i\]

Now, we adapt $\epsilon$ to this choice based on the following observation.
\begin{claim}\label{clm-proj}
Let $u\in \R^{g-1}$ be a vector with $|u|_\infty \leq \epsilon$. 
Then, in the representation $u = \sum_{i\leq g-1}\alpha_i\Delta_i$
(it exists and is unique as the $\Delta_i$'s form a basis of $\R^{g-1})$),
it must be the case that $|\alpha_i|\leq \epsilon \cdot g!$.  
\end{claim}

To prove the claim we apply Fact~\ref{fact-cramer} to $M=(\Delta_1||\Delta_2||\ldots \Delta_{g-1})$, and use Observation~\ref{obs-1} to bound each $|{M}^{-1}_{i,j}|$ as $|C_{i,j}|\leq (g-1)!/1=(g-1)!$. Now, the solution to $Mx=u$ is $M^{-1}u$, thus we get $|x|_\infty\leq (g-1)(g-1)!\epsilon\leq g!\epsilon$, as required (here $g-1$ is the length of $u$).

We can rewrite a convex combination of the $Y_i$'s as
\begin{equation}\label{eq-1}
\sum_{i\leq g}\alpha_iY_i=Y_1+\sum_{i\leq g-1}\alpha_{i+1} \Delta_i
\end{equation}
where the $\alpha_i$'s on the right hand side are non-negative integers summing to \emph{at most} $1$ (and move back and forth between the two representations). In particular, we have
\[v = Y_1+1/4(g-1)\sum_{i\leq g-1}\Delta_i\]
Recall also that the resulting row distribution is
$o'=(1-\epsilon)v + e'$, where $|e'|_\infty\leq \epsilon$.
Thus, we have $e'=\sum_{i\leq g-1}\alpha_i\Delta_i$, where $|\alpha_i|\leq g!\epsilon$. 

Thus, we have
\[o'=(1-\epsilon)v+e'=Y_1+(1-\epsilon)1/g\sum_{i\leq g-1}\Delta_i+(e'-\epsilon Y_1)\]
Let us write $w=e'-\epsilon Y_1$. Clearly, $|w|_\infty\leq 2\epsilon$.
Here $|\beta_i|\leq 2\epsilon$ for each $i$.
Thus, from Claim~\ref{clm-proj} we have
\[o'= Y_1+\sum_{i\leq g-1}((1-\epsilon)1/4(g-1)+\beta_i)\Delta_i\]

where $|\beta_i|\leq 2g!\epsilon$. Thus (since $g\geq 2$), picking $\epsilon=1/10(g-1)(g!)$, we obtain $o'$ of the form presented in Equation~\ref{eq-1}, which falls in the required region (the coefficients of the $\Delta_i$'s are all non-negative and sum to at most $1$). 

}

\section{Proof of \texorpdfstring{\cref{lem:COT}}{Lemma 3}}\label{sec:IKOPS}
In the following, fix a function $g:(\X\cup\set{\bot})\times\Y\mapsto\set{\bot,0,\ldots,k-1}$ satisfying $g(x,y)=\bot$ if and only if $x=\bot$. In this section we show how to construct a protocol for computing the function $g$ in the 1-round $\OThybrid$ model. The protocol we construct has perfect client security, and has strong statistical server security. Our protocol is a modified version of the protocol by \citet{IKOPS11}.\footnote{The original protocol by \cite{IKOPS11} have a simple reduction from the problem of computing a general function $f$ to computing $g$.} Their protocol is parametrized with $\eps$, and we denote this protocol by $\Pi_{\IKOPS}(\eps)$. It is a single round protocol in the $\OThybrid$ model, that has $\eps$-statistical full-security. It is stated for functions computable by $\NC^0$ circuits, however, this is only done for improving concrete efficiency, which is not a concern in our paper. We therefore restate it for general functions, and bound its communication complexity as a function of $|\X|$, $|\Y|$, and $k$ (which are assumed to be finite in our work). 
% We next fully describe the \citet{IKOPS11} protocol.

\subsection{\texorpdfstring{The Protocol $\Pi_{\IKOPS}$}{The IKOPS Protocol}}
We next give the rough idea of $\Pi_{\IKOPS}$. First, we view the inputs $x$ and $y$ as a binary strings, and we let  $y=y_1,\ldots,y_m$ respectively.\footnote{We can assume \wlg that the size of $\X$ and $\Y$ are a power of 2. This is due to the fact that we can add new elements to $\X$ such that the new rows in $M_f$ are duplicates of existing rows. We then do the same to $\Y$. It is easy to see that the new function is computable with statistical (perfect) full-security if and only if the previous function is computable with statistical (perfect) full-security.} The parties will compute a ``certified OT'' functionality. We next give a brief overview of the IKOPS protocol. 

The main idea behind the $\Pi_{\IKOPS}$ is to have the server run an ``MPC in the head'' \cite{IPS08}. That is, the real server locally emulates the execution of a perfectly secure protocol $\Pi$ with many virtual servers performing the computation, and $2m$ virtual clients, denoted $\Cc_{1,0},\Cc_{1,1},\ldots,\Cc_{m,0},\Cc_{m,1}$, receiving output, where $m$ is the number of bits in the client's input $y$. The underlying protocol $\Pi$  computes a decomposable PRE $\hat{g} = (\hat{g}_0,\hat{g}_1,\ldots,\hat{g}_m)$ of $g$. Specifically, the output of client $\Cc_{j,b}$ in an execution of $\Pi$ is the  corresponds to the $j$-th bit of $y$, when the bit equals to $b$. 

% The idea is to have the server run an ``MPC in the head'' with $n$ (for some $n$ which will be determined later) virtual servers, denoted $\Sc_1,\ldots,\Sc_n$, doing the computation, and $2m$ virtual clients, denoted $\Cc_{1,0},\Cc_{1,1},\ldots,\Cc_{m,0},\Cc_{m,1}$, receiving outputs, in order to compute a decomposable PRE of the function $g$. Since the PRE is decomposable its output is of the form $\vect{\v_0\of{x},\v_{1,0}\of{x},\v_{1,1}\of{x},\ldots,\v_{m,0}\of{x},\v_{m,1}\of{x}}$. Here $\v_0$ depends only on $x$ and the randomness, while $\v_{j,b}$ depends only on $x$, the randomness, and the $j$-th bit of $y$ being equal to $b$. We can now make sure that the virtual client $\Cc_{j,b}$ will receive $\vect{\v_0\of{x},\v_{j,b}\of{x}}$ as an output.
The real client can then use OT, in order to recover the correct output of the PRE and reconstruct the output $g(x,y)$. As part of the ``MPC in the head'' paradigm, the client further ask the server to send a watchlist (the views of some of the virtual servers) and check consistency. If there was an inconsistency, then the client outputs $\bot$. To make sure that the client will not receive too large of a watchlist and break the privacy requirement, it will get each view with some (constant) probability independently of the other views.

Observe that although the client can use OT in order to receive the correct $\v_{i,y_i}$'s, the parties need to use string-OT, while they only have access to bit-OT. This technicality can be overcome using the perfect reduction from $\sOT{1}{n}{s}$ to $\OT$  that was put forward in the elegant work of~\citet{BCS96}, which also constitutes one of the few examples of perfect reductions to $\bOT{1}{2}$ known so far. They proved the following theorem.

\begin{theorem}\label{thm-int}%[\cite{BCS96}]
	There exists a protocol $\Pi_{\stb}=\vect{\srvr_{\stb},\clnt_{\stb},\local_{\stb}}$ in the 1-round $\OThybrid$ world that computes $\sOT{1}{n}{s}$ with perfect full-security. Furthermore, its communication complexity is $\ell\leq 5s(n-1)$. 
\end{theorem}

Thia protocol, however, has slight problem. By tampering with the outputs of the virtual clients, a malicious server could force the output of the real client to be $g(x,y)$ for some inputs $y$ and force the output to be $\bot$ for other values of $y$, where the choice is \emph{completely determined} by the adversary. To overcome this problem, we replace $g$ with a function $g'$ where each bit $y_i$ is replaced with $m'$ random bit whose XOR equals to $y_i$, for some large $m'$.\footnote{This method has the disadvantage of increasing the length of the client's input and as a result increase the communication complexity, so \cite{IKOPS11} suggested a different approach. We stick with the presented approach, as we prefer simplicity over concrete efficiency.} Here, the adversary does not have complete control over which inputs the client will output $f(x_0,y)$, and for which inputs it will output $f(x,y)$.
% Then, if a malicious server tampered with the outputs of $m'+1$ of the virtual clients that corresponds to the same input bit $y_i$, the client will output $\bot$ for every $y$, hence this attack can be simulated. If the server tampered with at most $m'$ virtual clients, then for every $y$ with high probability (relative to the number of tampered clients) the client will notice the attack, hence in this case it will output $\bot$ implying security. 
We next describe the protocol formally. We start with some notations.
% For now, we assume that the server send it in the clear, and later we show how to remove this assumption.
% \begin{proposition}\label{prop:noClearMsg}
% Let $f:\X\times\Y\mapsto\Z$ be some function. Assume that there exists a single round protocol $\Pi'=\vect{\srvr',\clnt',\local'}$ in the $\OThybrid$ model ($\Pi'$ is \emph{not} in the 1-round $\OThybrid$ world) that computes $f$, in the following way. On input $x$ the server $\Sc$ samples $(\a'_1,\a'_2)\from\srvr'\of{x}$, and on input $y$ the client $\Cc$ samples $\b\from\clnt'\of{y}$. $\Sc$ and $\Cc$ send $\a'_1$ and $\b'$ to the OT functionality respectively. $\Cc$ receives $\a'_1[\b']$, computes $z\from\local'\of{y,\b',\a'_1[\b'],\a'_2}$ and outputs $z$. In other words, $\Pi'$ is executed similarly to protocol in the 1-round $\OThybrid$ world, with an additional message $\a'_2$ sent in the clear from the server to the client. 

% For any $\eps(\cdot)$, if $\Pi'$ computes $f$ with $\eps$-statistical full-security there exists a protocol $\Pi$ in the (standard) 1-round $\OThybrid$ model that computes $f$ with $\eps$-statistical full-security.
% \end{proposition}

% The proof of \cref{prop:noClearMsg} is presented in\TODO{ADD}. We next fully describe $\Pi_{\IKOPS}\of{\eps}$. 
\paragraph{Notations.}
Throughout the following section, we let $m$ be the number of bits in the binary representation of the elements of any client-input $\y$. Let $m'=m'(\eps)=\ceil{\log\of{\eps^{-1}}}+1$ and let $\Enc:\zo^{m}\mapsto\left(\zo^{m'}\right)^{m}$ be a randomized function that on input $y_1,\ldots,y_m$, outputs $m\cdot m'$ random bits $\vect{y_i^1,\ldots,y_i^{m'}}_{i\in[m]}$ conditioned on $\xor_{j=1}^{m'}y_i^j=y_i$ for every $i\in[m]$. We also let $\Dec:\left(\zo^{m'}\right)^{m}\mapsto\zo^{m}$ be the inverse of $\Enc$, namely, $$\Dec\of{\vect{y_i^1,\ldots,y_i^{m'}}_{i\in[m]}}=\vect{\bigoplus_{j=1}^{m'}y_i^j}_{i\in[m]}.$$
Finally, we let $g':(\X\cup\set{\bot})\times\left(\zo^{m'}\right)^{m}\mapsto\set{\bot,0,\ldots,k-1}$ be defined as
$$g'\of{x,\vect{y_i^1,\ldots,y_i^{m'}}_{i\in[m]}}=g\left(x,\Dec\of{\vect{y_i^1,\ldots,y_i^{m'}}_{i\in[m]}}\right),
$$
and let $\hat{g}$ be a decomposable PRE of $g'$.

\begin{protocol}[$\Pi_{\IKOPS}\of{\eps}$]~

Input: Server has input $x\in(\X\cup\set{\bot})$ and client has input $\y\in\zo^m$.
    
\begin{itemize}
	\item$\srvr\of{x}$\emph{:} 
    \begin{enumerate}
    	\item The server $\Sc$ runs ``MPC in the head'' for the following functionality. There are $\changed{n=O\of{\log\of{\eps^{-1}}\cdot m}}$ $n=\Theta\of{\log\of{\eps^{-1}}}$ virtual servers $\Sc_1,\ldots,\Sc_n$ with inputs and $2m\cdot m'$ virtual clients $\Cc_{1,0},\Cc_{1,1},\ldots,\Cc_{m\cdot m',0},\Cc_{m\cdot m',1}$ receiving outputs. Each virtual server holds a share of the $\Sc$'s input and randomness, where the shares are in an $n$-out-of-$n$ Shamir's secret sharing scheme. Each virtual client $\Cc_{j,b}$ will receive $\hat{g}_{j,b}(x)$, namely, it will receive the $(j,b)$-th component of the decomposable PRE where the first part of the input is fixed to $x$. In addition every virtual client will hold $\hat{g}_0\of{x}$ which is the value of $\hat{g}$ that depends only on the bits of $x$ and the randomness.
        
        \item The virtual parties execute a multiparty protocol in order to compute $\hat{g}$. The protocol used has perfect full-security against $t=\ceil{n/3}-1$ corrupted virtual servers and any number of corrupted virtual clients (\eg The BGW protocol \cite{BGW88}). We assume \wlg that the virtual clients receive messages at the last round of the protocol.
        
        \item Let $V_{j,b}$ be the view of $\Cc_{j,b}$, and let $\a_1=\vect{\srvr_{\stb}\of{V_{j,0},V_{j,1}}}_{j\in[m\cdot m']}$.
        
        \item Let $V_i$ be the view of $\Sc_i$. For each $i\in[n]$ the server creates $\tilde{\a}_i$ of length $\ceil{2n/t}$, where $V_i$ is located in a randomly chosen entry, while the other entries are $\bot$ (This allows the server to send each $V_i$ with probability $t/2n$). Let $\a_2=\vect{\srvr_{\stb}\of{\tilde{\a}_i}}_{i\in[n]}$.
        
        \item $\Sc$ outputs $\a=(\a_1,\a_2)$.
    \end{enumerate}
    
    
    \item$\clnt\of{\y}$\emph{:}
    \begin{enumerate}
    	\item The client computes $\vect{y_i^1,\ldots,y_i^{m'}}_{i\in[m]}=\Enc\of{\y}$.
        
        \item Let $\b_1=\vect{\clnt_{\stb}\of{y_j^{j'}}}_{j\in[m],j\in[m']}$.
        
        \item Let $\b_2=\vect{\clnt_{\stb}\of{1}}_{i\in[n]}$ (\ie a constant vector).
        
        \item $\Cc$ outputs $\b=(\b_1,\b_2)$.
    \end{enumerate}
    
    \item$\local\of{\y,\b,\c'}$\emph{:}
    \begin{enumerate}
    	\item Let $\c=\vect{\local_{\stb}\of{c'_i}}_{i}$\footnote{The function $\local$ is different when applying to recover $\a_1[\b_1]$ from when applying to recover $\a_2[\b_2]$. To keep the presentation simple we will abuse notation and write as if they are the same function.} and let $(\c_1,\c_2)=\c$, where $\c_1$ corresponds to the outputs and $\c_2$ corresponds to the watchlist.
        
        \item For every $V_{j,b}$ in $\c_1$, we may write \wlg that $V_{j,b}=\vect{V_{j,b}^i}_{i\in[n]}$, where $V_{j,b}^i$ is the message that $V_{i}$ sends to $V_{j,b}$.
        \bnote{The original IKOPS protocol did not need this $V_{j,b}^i$, right?}
        
        \item If there exists $V_{i_1},V_{i_2}\in\c_2$ or $V_i\in\c_2$ and $V_{j,b}^i\in\c_1$ that are inconsistent, output $\bot$.
        
        \item Otherwise, apply the PRE decoder on $\c_1$ to recover the output $z$.
    \end{enumerate}
\end{itemize}
    \deleted{
\begin{enumerate}
    \item\label{step:getout} Let $V_{1,0},V_{1,1},\ldots,V_{m\cdot m',0},V_{m\cdot m',1}$ be the view of $\Cc_{1,0},\Cc_{1,1},\ldots,\Cc_{m\cdot m',0},\Cc_{m\cdot m',1}$ respectively. $\Sc$ and $\Cc$ then use the $\sOT{1}{2}{s}^{m\cdot m'}$ \TODO{Compute $s$} functionality so that $\Cc$ receives the outputs $\vect{V_{i,y^j_i}}_{i\in[m],j\in[m']}$. This is done as follows. $\Sc$ computes $\vect{\srvr_{\stb}\of{V_{i,0},V_{i,1}}}_{i=1}^{m\cdot m'}$ and $\Cc$ computes $\vect{\clnt_{\stb}\of{y_i^{j'}}}_{i\in[m],j\in[m']}$.\TODO{Decide if to keep explanation.}
    
    \item\label{step:getview} Let $V_1,\ldots,V_n$ be the view of $\Sc_1,\ldots,\Sc_n$ respectively. In parallel to Step~\ref{step:getout}, $\Sc$ and $\Cc$ use $\sOT{1}{2}{s}^n$ \TODO{Compute $s$} again, so that $\Cc$ receives each $V_j$ with probability $p\in[t/4n,t/2n]$ independently of the other views. 
    
    \item Without loss of generality we may write $V_{j,b}=\vect{V^i_{j,b}}_{i\in[n]}$ where each $V^i_{j,b}$ is the message that $\Cc_{j,b}$ receives from $\Sc_i$. The client verify consistency between each pair of views he received, that is, it check consistency between each $V_{i_1}$ and $V_{i_2}$ and in addition, between each $V_{j,b}^i$ and $V_i$. If there was no inconsistency, then the client apply the decoder for the randomized encoding to recover the output $z$. Otherwise the client outputs $\bot$.
\end{enumerate}
}
\end{protocol}

\deleted{We are now ready to fully describe the protocol by \citet{IKOPS11}. The protocol is used to compute the function $f$.

\begin{protocol}[$\Pi_{\IKOPS}\of{\eps}$]~

	Input: Server $\Sc$ has input $x\in\X$ and client $\Cc$ has input $y\in\zo^m$. Both parties hold a security parameter $1^{\kappa}$.
    
    \begin{enumerate}    
    \item $\Sc$ and $\Cc$ execute $\Pi_{\COT}\of{\eps}$ in order to compute $g$, with inputs $x$ and $\Enc\of{y}$ respectively.
    
    \item If $\Cc$ receive $z\ne\bot$ then it outputs $z$. Otherwise, it outputs $f(x_0,y)$ for some default value $x_0\in\X$.
    \end{enumerate}
\end{protocol}
}
% Intuitively, the protocol is secure against malicious server, since to much deviation from the inner MPC protocol would be caught by the client with high-probability. If the client is malicious, then with high enough probability it will \emph{not} receive the view of more than $t$ servers, hence by the assumed security of the computation done in Step~\ref{step:IKOPScomp} of $\Pi_{\IKOPS}$, the client will not learn anything on the input of the server.
We summarize the properties of the protocol below.

\begin{theorem}
	For every $\eps>0$, $\Pi_{\IKOPS}\of{\eps}$ computes $g$, with correctness, strong $\eps$-server security, and $\eps$-client security. Furthermore, using the PRE from \cite{IK02,AIK04} and the BGW protocol, the $\CC$ will be the following. Let $\gamma_i$ denote the size of the smallest formula for evaluating the $i$'th bit of $g(x,y)$, and let $\gamma=\max_{i} \gamma_i$.	Then, $\Pi_{\IKOPS}$ has $\CC$ of \changed{$\ell=\log\of{k}\cdot\tilde{O}\of{\log\of{|\Y|}\cdot\left(\log\of{{\eps^{-1}}}+\alpha\right)^2}+\polylog(\eps^{-1})$.}
    $$\ell=O\of{\gamma^2\cdot\log k\cdot\log|\Y|\cdot\polylog\of{\eps^{-1}}}.$$
\end{theorem}

% In a nutshell, in the $\Pi_{\IKOPS}$ protocol, reduces the evaluation of $f(x,y)$ to secure evaluation of a single instance of $\ell$ parallel instances of $\sOT{1}{2}{h}$ functionality for certain parameters $h,\ell$ depending on $f,\eps$. This is done using a decomposable randomized encodings of $f$~\cite{IK02}. Here we have $\ell=\log{|X|}$ - the input to $i$'th OT instance is the bit $x_i$. 
% The $y$ is mapped to a string sequence ${(s_{1,0},s_{1,1},\ldots,s_{l,0},s_{l,1})}$ fed to the OT's in a certain manner.

% Now, to securely evaluate the resulting functionality in the malicious setting, the OT is replaced by a COT (certified OT) functionality. The COT returns the client the output, and additionally reports whether the resulting string is consistent with some $y$ and randomness $r$, as prescribed by reduction from $f(x,y)$ to the OT instances. 
% $\Pi_{COT}$ verifies that the OT input $s\in\{0,1\}^{2l}$ it feeds to the OT oracle is consistent with some $y,r$ for the reduction. 
% Along with $s$, the server feeds a representation of $y,r$ as a witness that $s$ is consistent.
% It gives client $C_i$ 
% the OT output along with a bit on whether it is consistent (with that witness $y,r$ common for all indices) or not.

% In the COT implementation, the server runs MPC in the head of an $n'$-party protocol $\Pi$ for evaluating the (randomized) mapping from a pair $(y,r)$ to a sequence $s$. More concretely, the protocol consists of a sender that privately sends $n$ virtual servers its inputs $y,r$, and some $2\log{h}$ clients that receive corresponding OT outputs (the clients do not have inputs). There are also $2l$ clients have no inputs, but client $C_{i,b}$ gets the output of the $i$'th OT instance on input $x_i=b$. 
% In $\Pi$, the virtual servers send messages to the clients in the last round of the protocol.

% The COT client chooses the strings corresponding to the views seen by the virtual clients corresponding to its input $x$. Additionally, it asks for the entire view of the each of the virtual servers with some small constant probability $\delta'$. We observe that these so called \emph{watchlists} (the client watches only a small fraction of the virtual server), along with the requests for client's views can be perfectly reduced in one round to $\bOT{1}{2}$ oracles.


% This MPC protocol $\Pi$ is secure against malicious corruption of $\delta n$ of the $n$ parties. With high probability, the client will see $p/2n < \delta' n<\delta n$ of the views, catching cheating with high probability, but not learning anything besides $f(x,y)$.  
% For a choice of $\delta'$ as above, the IKOPS protocol already happens to be statistically private against malicious clients.

% There is however (small) non-zero probability of the client learning too much (in the worst case, $f(x,y)$ for all $x\in X$), by ending up watching too many of the virtual parties' view (potentially all of them). 

% Thus, $\Pi_{IKOPS}$ is not perfectly server-private.
% In the following section, we slightly tweak $\Pi_{IKOPS}$, making watchlists deterministic, thereby making it perfectly server-private. In Section~\cite{sec-serv-perf}, using geometric techniques, we demonstrate how to make the protocol from Section~\ref{sec-client-pr} perfectly client correct. Here we critically rely on the fact that $\Pi_{IKOPS}$ satisfies statistical enhanced client privacy, rather than just standard statistical client privacy. 

Observe that $\Pi_{\IKOPS}$ has a (small) non-zero probability of the client seeing to many views of the virtual servers (in the worst case all of them which gives him the knowledge of $x$). Thus, $\Pi_{\IKOPS}$ is not perfectly client secure. 
% Additionally, a malicious server might still be able to have the client output $\bot$ for some inputs $\y$, but output $g(x,\y)$ for other inputs $\y$, with non-zero probability.

In the following section, we slightly tweak $\Pi_{\IKOPS}$, making the watchlists deterministic, thereby making it perfectly client secure. The new protocol will have the desired properties as stated in \cref{lem:COT}.\deleted{ In Section~\cite{sec-serv-perf}, using geometric techniques, we demonstrate how to make the protocol from Section~\ref{sec-client-pr} perfectly server secure. Here we critically rely on the fact that $\Pi_{\IKOPS}$ satisfies strong server security, rather than just standard statistical server security. }

%\subsection{Making $\Pi_{\COT}$ Perfectly Client Secure}\label{sec-client-pr}

\subsection{Setting Up Deterministic Watchlists}\label{sec:detWatch}

Recall the problem with client privacy was in the fact that the client may watch the internal state of too make servers, breaching security of the protocol $\Pi_{\IKOPS}$, and thus of the entire construction.
To solve this problem, we replace the probabilistic watchlist setup with a \emph{deterministic watchlist} setup that allows the honest client to learn exactly $t/2$ of the views of its choice, while no malicious client can learn more than $t$ of the values. We also allow the server to input $\bot$, in which case the client should output $\bot$.

In order to achieve the deterministic watchlist, the parties will use a protocol for computing $\sOT{t}{n}{s}$. We do know, however, if such protocol even exists. Instead, we relax the security notion a bit, so that we will be able to construct the protocol, and it will still suffice for the main protocol. Specifically, we show how in the $\OThybrid$ model, the parties can compute $\sOT{t}{n}{s}$ in a single round, where a malicious client will only be able to learn at most $2t$ strings rather than $t$. %Furthermore, the ideal-world server has an additional input $\bot$ so that if it sends it to the trusted party, the client's output will $\bot$.

Let $t,n,s\in\N$ where $t<n$, and $s\geq 1$. For simplicity, we assume that $t$ is even. Let $f_1$ and $f_2$ be the $\sOT{t/2}{n}{s}$ and $\sOT{t}{n}{s}$ functionalities respectively. \deleted{We extend each $f_i$ above into so that the server's domain contains $\bot$, and $f'_1(\bot,y)=\bot$ and $f'_2(\bot,y)=\bot$ for every $y\in\Y$. }The protocol $\Pi_{\rampOT}=\vect{\srvr_{\rampOT},\clnt_{\rampOT},\local_{\rampOT}}$ computes \changed{$f'_1$} $f_1$ in the 1-round $\OThybrid$ model. The idea is the following. The parties will use protocol $\Pi_{\stb}$ in order to simulate computation of $n$ instances of $\sOT12{sn}$ in parallel. The $i$-th pair of bits the that server will send consist of a masking of $i$-th string $x_i$, and a Shamir's share of the concatenation of all of the maskings. The client will then recover the maskings of the correct outputs alongside the shares, which will help him to reconstruct the outputs. We next formally describe the protocol.

\begin{construction}[$\Pi_{\rampOT}$]~

Input: Server $\Sc$ holds $\x=\vect{x_1,\ldots,x_n}\in\left(\zo^{s}\right)^n$, and the client $\Cc$ holds $\y=\set{y_1,\ldots,y_{t}}\su[n]$.

%The parties perform $n$ $\sOT{1}{2}{sn}$'s in parallel (implemented via the ${\bOT{1}{2}}^\ell$ using parallel instances of $\INT$). 
\begin{itemize}
	\item $\srvr_{\rampOT}\of{\x}$\emph{:} Samples $n$ random strings $r_1,\ldots,r_n\from\{0,1\}^s$. For every $i\in[n]$, let $\myvec{r}[i]\in\zo^{sn}$ be a share of $\myvec{r}=(r_1,\ldots,r_n)$ in an $(n-t)$-out-of-$n$ Shamir's secret sharing (We pad $\myvec{r}[i]$ if needed). Output $\a = \big(\srvr_{\stb}\of{(x_i\oplus r_i,\myvec{r}[i])}\big)_{i\in[n]}$ (the $x_i\xor r_i$'s are padded accordingly).
            
	\item $\clnt_{\rampOT}\of{\y}$\emph{:} Output 
    $\b=(\clnt_{\stb}\of{b_1},\ldots,\clnt_{\stb}\of{b_n})$, where $b_i=0$ if and only if $i\in\y$.
            
	\item $\local_{\rampOT}\of{\y,\b,\c'}$\emph{:} Let $\c=\vect{\local_{\stb}\of{c'_i}}_{i=1}^{n}$, let $\c_1=\vect{c_i}_{i\in\y}$, and let $\c_2=\vect{c_i}_{i\notin\y}$. If the elements in $\c_2$ agree on a common secret $\myvec{r}\in\zo^{sn}$, then output $\c_1\xor\vect{r_i}_{i\in\y}$. Otherwise, output $\bot$.
            
%             Here $v_i$ is the string returned by the $i$'th instance of $\INT$.
% 			Let $w_i = {\INT}_R(y,b_i,v_i)$ denote the output of the $i$'th instance of $\INT$. Use the $w_i$'s in $SR=[n]\setminus{y}$ to recover the secret vector $r$ as follows:
% 			\begin{enumerate}
% 		 		\item If all subsets of size $n-2k_1$ of $SR$ agree on the same secret $r$, output $(w_i\oplus r_i)_{i\in x}$. 
% 		 		\item Otherwise, output $\bot$.   
% 		\end{enumerate}
	\end{itemize}
\end{construction}

\begin{lemma}\label{thm:rampOT}%[a $\sOT{k_1,k_2}{n}{s}$ protocol]
	$\Pi_{\rampOT}$ computes $f_1$ with $\CC$ of $\ell\leq 5s\cdot n(n-1)$\TODO{Verify}, such that the following holds:
	\begin{itemize}
	\item $\Pi_{\rampOT}$ is correct.
	\item $\Pi_{\rampOT}$ has perfect input-value security.
	\item For any non-uniform adversary $\adv$ corrupting the client in the $\OThybrid$ world, there exists a non-uniform simulator $\Sim_{\adv}$ corrupting the client in the ideal-world \emph{of $f_2$}, such that for all $\kappa\in\N$, $x\in\left(\zo^s\right)^n$, $\y\su[n]$ of size $t/2$, and $\aux\in\zo^*$ it holds that
    $$\View^{\HYBRID}_{\adv\of{\y,\aux},\Pi_{\rampOT}}\of{x,\y,1^{\kappa}} \equiv\View^{\IDEAL}_{\Sim_{\adv}\of{\y,\aux},f_2}\of{x,\y,1^{\kappa}}.$$
	In other words, although the simulator receive $t/2$ indexes as inputs, it is allowed to ask for $t$ strings from the server's input.
	 \end{itemize} 
\end{lemma}

Intuitively, a malicious server cannot force the client to reconstruct two different secrets $\myvec{r}$ for two different input. This is due to the fact that for every two different inputs the set of common $b_i$'s that are 1 is of size at least $n-t$. This implies that up to a certain set of client-inputs that is chosen by the adversary, the client will receive  a correct output.

As for a malicious client, observe that it can ask for at most $t$ masked values, as otherwise it will not be able to recover the secret. We next incorporate $\Pi_{\ROT}$ into $\Pi_{\IKOPS}$ to get a protocol that is perfectly client-secure. The full proof of \cref{thm:rampOT} is deferred to \cref{sec:missing}.

\subsection{Upgrading $\Pi_{\IKOPS}$.}\label{sec:up-ikops}
We are finally ready to prove \cref{lem:COT}. As stated in \cref{sec:detWatch}, we replace the randomly chosen watchlist with a deterministic one using $\Pi_{\ROT}$. Formally, the protocol is described as follows.

\begin{protocol}[$\Pi^+_{\IKOPS}\of{\eps}$]~

Input: Server has input $x\in(\X\cup\set{\bot})$ and client has input $\y\in\zo^m$.
    
\begin{itemize}
	\item$\srvr\of{x}$\emph{:} 
    \begin{enumerate}
    	\item The server $\Sc$ runs ``MPC in the head'' for the following functionality. There are \changed{$n=O\of{\log\of{\eps^{-1}}\cdot m}$} $n=\Theta\of{\log\of{\eps^{-1}}}$ virtual servers $\Sc_1,\ldots,\Sc_n$ with inputs and $2m\cdot m'$ virtual clients $\Cc_{1,0},\Cc_{1,1},\ldots,\Cc_{m\cdot m',0},\Cc_{m\cdot m',1}$ receiving outputs. Each virtual server holds a share of the $\Sc$'s input and randomness, where the shares are in an $n$-out-of-$n$ Shamir's secret sharing scheme. Each virtual client $\Cc_{j,b}$ will receive $\hat{g}_{j,b}(x)$, namely, it will receive the $(j,b)$-th component of the decomposable PRE where the first part of the input is fixed to $x$. In addition every virtual client will hold $\hat{g}_0\of{x}$ which is the value of $\hat{g}$ that depends only on the bits of $x$ and the randomness.
        
        \item The virtual parties execute a multiparty protocol in order to compute $\hat{g}$. The protocol used has perfect full-security against $t=\ceil{n/3}-1$ corrupted virtual servers and any number of corrupted virtual clients (\eg The BGW protocol \cite{BGW88}). We assume \wlg that the virtual clients receive messages at the last round of the protocol.
        
        \item Let $V_{j,b}$ be the view of $\Cc_{j,b}$, and let $\a_1=\vect{\srvr_{\stb}\of{V_{j,0},V_{j,1}}}_{j\in[m\cdot m']}$.
        
        \item Let $V_i$ be the view of $\Sc_i$, and let $\a_2=\srvr_{\ROT}\of{V_1,\ldots,V_n}$.
        
        \item $\Sc$ outputs $\a=(\a_1,\a_2)$.
    \end{enumerate}
    
    
    \item$\clnt\of{\y}$\emph{:}
    \begin{enumerate}
    	\item The client computes $\vect{y_i^1,\ldots,y_i^{m'}}_{i\in[m]}=\Enc\of{\y}$.
        
        \item Let $\b_1=\vect{\clnt_{\stb}\of{y_j^{j'}}}_{j\in[m],j\in[m']}$.
        
        \item Sample a subset $\W\su[n]$ of size $t/2$ uniformly at random (For simplicity we assume that $t$ is even).
        
        \item Let $\b_2=\clnt_{\ROT}\of{\W}$.
        
        \item $\Cc$ outputs $\b=(\b_1,\b_2)$.
    \end{enumerate}
    
    \item$\local\of{\y,\b,\c'}$\emph{:}
    \begin{enumerate}
    	\item Let $\c=\vect{\local_{\stb}\of{c'_i}}_{i}$ and let $(\c_1,\c_2)=\c$, where $\c_1$ corresponds to the outputs and $\c_2$ corresponds to the watchlist.
        
        \item For every $V_{j,b}$ in $\c_1$, we may write \wlg that $V_{j,b}=\vect{V_{j,b}^i}_{i\in[n]}$, where $V_{j,b}^i$ is the message that $V_{i}$ sends to $V_{j,b}$.
        
        \item If there exists $V_{i_1},V_{i_2}\in\c_2$, or $V_i\in\c_2$ and $V_{j,b}^i\in\c_1$ that are inconsistent, output $\bot$.
        
        \item Otherwise, apply the PRE decoder on $\c_1$ to recover the output $z$.
    \end{enumerate}
\end{itemize}
\end{protocol}

\begin{lemma}[Restatment of \cref{lem:COT}]
For every $\eps>0$, $\Pi_{\IKOPS}^+\of{\eps}$ computes $g$ with is correctness, has strong $\eps$-server security, and has perfect client security. Furthermore, using the PRE from \cite{IK02,AIK04} and the BGW protocol, the $\CC$ will be the following. Let $\gamma_i$ denote the size of the smallest formula for evaluating the $i$'th bit of $g(x,y)$, and let $\gamma=\max_{i} \gamma_i$.	Then, $\Pi^+_{\IKOPS}$ has $\CC$ of \changed{$\ell=\log\of{k}\cdot\tilde{O}\of{\log\of{|\Y|}\cdot\left(\log\of{{\eps^{-1}}}+\alpha\right)^2}+\polylog(\eps^{-1})$.}
    $$\ell=O\of{\gamma^2\cdot\log k\cdot\log|\Y|\cdot\polylog\of{\eps^{-1}}}.$$
\end{lemma}

\begin{proof}
% The protocol we construct is denoted $\Pi_{\IKOPS}^+\of{\eps}$. Recall that in $\Pi_{\IKOPS}$ the server runs an ``MPC in the head'' with $n=O(\kappa\cdot m)$ virtual server $\Sc_1,\ldots,\Sc_n$, and $2m\cdot m'$ virtual clients $\Cc_{1,0},\Cc_{1,1},\ldots,\Cc_{m\cdot m',0},\Cc_{m\cdot m',1}$. In Step~\ref{step:getout} the client receive $m\cdot m'$ outputs, each belongs to a different virtual client. The protocol $\Pi_{\IKOPS}^+\of{\eps}$ for computing $g$, is the same as $\Pi_{\IKOPS}$ with Step~\ref{step:getview} replaced with the following. Let $V_1,\ldots,V_n$ be the views of $\Sc_1,\ldots,\Sc_n$ respectively. In parallel to Step~\ref{step:getout}, $\Cc$ chooses a random subset $\W\su[n]$ of size $t/2$. $\Sc$ and $\Cc$ then uses $\Pi_{\rampOT}$ to compute $\sOT{t/2}{n}{s}$\bnote{Compute $s$} so that $\Cc$ will receive $\set{V_i}_{i\in\W}$. 

Correctness trivially holds. We next prove that the protocol is strong $\eps$-server secure. Consider a message $\a^*$ send by a malicious server in the $\OThybrid$ world. We need to show the existence of a certain probability vector $\p\in\R^{|\X|+1}$. With that in mind, we will describe the vector $\p$ using a simulator $\Sim$ that will describe the probability of sending $x^*$ to $\trustp$ as an input. The simulator holds $\a^*$ as an input.
\begin{enumerate}
	\item Write $\a^*=(\a^*_1,\a^*_2)$, where $\a^*_1$ corresponds to the outputs and $\a^*_2$ corresponds to the watchlist.
    
    \item Apply the simulator guaranteed by the security of $\Pi_{\stb}$ to each pair of messages in $\a^*_1$ to obtain $V_{1,0},V_{1,1},\ldots,V_{m\cdot m',0},V_{m\cdot m',1}$, and apply the simulator guaranteed by $\Pi_{\rampOT}$ for each pair in $\a^*_2$ to obtain $V_1,\ldots,V_n$ and a predicate $P$ (If the output of the simulator is $\bot$ instead of views, then send $\bot$ to $\trustp$).
    
%     \item If for every choice of $b_i$'s it is the case where $\vect{V_{i,b_i}}_{i=1}^{m\cdot m'}$ will be decoded to the output of $\bot$, then send $\bot$ to the trusted party.
    
    \item Generate an inconsistency graph $G'$, with $[n]$ as vertices, and where $\set{i_1,i_2}$ is an edge if and only if $V_{i_1}$ and $V_{i_2}$ are inconsistent, and let $\VC$ be the minimum vertex cover of $G'$.\footnote{Recall that we do not care about the efficiency of simulator. Using a 2-approximation to compute the minimum vertex-cover also suffices, while slightly tweaking $t$.} If $\VC>t$ then send $\bot$ to $\trustp$.
    
    \item Otherwise, pick a subset $\W\su[n]$ of size $t/2$ uniformly at random. If there exists $i_1,i_2\in\W$ with an edge between them in $\G$ or $P(\W)=1$, then send $\bot$ to $\trustp$.
    
    \item Otherwise, extend $G'$ into an inconsistency graph $G$, where there are new vertices $(j,b)\in[m\cdot m']\times\zo$, and $\set{i,(j,b)}$ is an edge if and only if $V_{j,b}^i$ is inconsistent with $V_i$ (\ie the output of $\Cc_{j,b}$ is inconsistent with the view of $\Sc_i$ in some message recieved from $\Sc_i$).
    
%     \item Let $\vect{y_j^1,\ldots,y_j^{m'}}_{j\in[m]}\from\Enc\of{0^m}$, and let $\T=\set{(j\cdot j', y_j^{j'})}$. If there exists a vertex in $\T$ with an edge to a vertex in $\S$ then send $\bot$ to $\trustp$.
    
    \item Let $\S\su[m\cdot m']\times\zo$ be the set of vertices corresponding to the virtual clients, that have an edge with a vertex in $\W$. If there exists $j\in[m]$ such that either
    \begin{itemize}
    	\item $\left(m'(j-1)+j',0\right),(m'(j-1)+j',1)\in\S$ for some $j'\in[m']$, or
        
        \item for every $j'\in[m']$ exactly one the vertices $(m'(j-1)+j',0),(m'(j-1)+j',1)$ is in $\S$,
    \end{itemize}
    then send $\bot$ to $\trustp$.
    
    \item Otherwise, apply the MPC simulator on the virtual servers $\Sc_i$, where $i\in\VC$, to get an input for each of virtual servers in $\VC$. The simulator $\Sim$ can then use the inputs of the other virtual servers to get an effective input $x^*\in(\X\cup\set{\bot})$, and send it to $\trustp$.
\end{enumerate}
\bnote{We didn't use the fact that the simulator for $\Pi_{\ROT}$ is deterministic.}

The vector $\p$ is then defined as $p_{x^*}=\pr{\Sim\text{ sends }x^*\text{ to }\trustp}$. To alleviate notations, we will write $\q=\q^{\Pi_{\IKOPS}^+\of{\eps}}\of{\a^*}$. Fix $\y\in\zo^{m}$ and $z\in\set{\bot,0,\ldots,k-1}$. We need to show that\footnote{In fact we can show something stronger -- that the $\ell_1$ distance (\ie statistical distance) is smaller than $\eps\cdot p_\bot$, implying that the protocol has standard $\eps$-server security. However, this does not improve our result and the proof is therefore omitted.}
\begin{align}\label{eq:toshow}
	\abs{q_{\y,z}-M_g^T\of{\cdot,(\y,z)}\cdot\p}\leq\eps\cdot p_\bot.
\end{align}

Observe that since $\Pi_{\stb}$ and $\Pi_{\ROT}$ has perfect server-security, each $V_{m'(j-1)+ j',b}$ and each $V_i$ in the $\OThybrid$ world is distributed exactly the same as its counterpart in the ideal world. Therefore, we may condition on the event that they are indeed the same. Furthermore, by the security of $\Pi_{\ROT}$, we may also assume that the watchlist $\W$ is distributed the same, and that $P(\W)=0$, as otherwise in both worlds the client will output $\bot$. In the following we fix the views and $\W$. We next separate into three cases, stated in the following claims (proven below). These claims together immediately imply \cref{eq:toshow}.

\begin{claim}\label{clm:largeVC}
If $\VC>t$ then \cref{eq:toshow} holds.
\end{claim}

\begin{claim}\label{clm:XNORconsistency}
Assume that $\VC\leq t$ and that for every $i\in\W$ and every $j\in[m]$, there exists $j'\in[m']$ such that either both $V_{m'(j-1)+j',0}$ and $V_{m'(j-1)+j',1}$ are consistent with $V_i$, or both are inconsistent with $V_i$. Then \cref{eq:toshow} holds. Moreover, there is perfect simulation.
\end{claim}

\begin{claim}\label{clm:XORconsistency}
Assume that $\VC\leq t$ and that there exists $i\in\W$ and $j\in[m]$, such that for every $j'\in[m']$ exactly one of the views $V_{m'(j-1)+j',0}$ and $V_{m'(j-1)+j',1}$ are inconsistent with $V_i$, then \cref{eq:toshow} holds. 
\end{claim}

\begin{proofof}{\cref{clm:largeVC}}
Since $\VC>t$ then the maximum matching in $G'$ is of size at least $(t+1)/2$. Therefore, in the $\OThybrid$ world, the expected number of edges that the client will have in its watchlist is at least $\frac{t+1}{2}\cdot\frac{\binom{n-2}{t/2-2}}{\binom{n}{t/2}}=\Theta\of{n}$. By applying Hoeffding's inequality,\footnote{Although Hoeffding's inequality is stated for the sum of independent random variables, it still works in our case since the sampled can be modeled as if we are picking vertices without repetitions. Sampling with repetitions only decreases the probability for an edge.} with probability at least $1-2^{-\Theta\of{n}}=1-\eps$ the client will output $\bot$. Since in the ideal-world the simulator sends $\bot$ to $\trustp$ with probability 1, \cref{eq:toshow} follows.
\end{proofof}

\begin{proofof}{\cref{clm:XNORconsistency}}
We separate into two cases. For the first case, assume that there exists $i\in\W$, $j\in[m]$, and $j'\in[m']$ such that both $V_{m'(j-1)+j',0}$ and $V_{m'(j-1)+j',1}$ are inconsistent with $V_i$. Then $(m'(j-1)+j',0),(m'(j-1)+j',1)\in\S$, hence the simulator will always send $\bot$. Furthermore, in the $\OThybrid$ world, for every input $\y\in\zo^m$ the client will see an inconsistency between either $V_{m'(j-1)+j',0}$ and $V_i$, or an inconsistency between either $V_{m'(j-1)+j',1}$ and $V_i$, hence \cref{eq:toshow} holds with no error.

By the assumptions of the claim, for the second case we may assume that for every $i\in\W$ and every $j\in[m]$, there exists $j'\in[m']$ such that both $V_{m'(j-1)+j',0}$ and $V_{m'(j-1)+j',1}$ are consistent with $V_i$. In this case, the output of the client in the ideal-world is determined by the MPC simulator. Since it is assumed to be perfect and $|\VC|\leq t$ bound from above the number of corrupted servers, it follows that \cref{eq:toshow} holds with no error.
\end{proofof}

\begin{proofof}{\cref{clm:XORconsistency}}
By construction, the ideal-world simulator will send always $\bot$. Additionally, in the $\OThybrid$ world, the client uses $\Enc$ on its input $\y$ to receive $m\cdot m'$ random bits $\vect{y_j^{j'}}_{j\in[m],j'\in[m']}$ conditioned on $\xor_{j'=1}^{m'}y_j^{j'}=y_j$. Since we assume that exactly $m'$ virtual clients, corresponding to the same input bit $y_j$, where tampered by the adversary, it follows that with probability at most $2^{-(m'-1)}\leq\eps$ the client will see only consistent views. \deleted{Therefore, for every $\y\in\zo^m$ it holds that 
$$\abs{q_{\y,\bot}-M_g^T\of{\cdot,(\y,\bot)}\cdot\p}=\abs{1-\eps -p_{\bot}}=\eps,$$
and for every $z\ne\bot$
$$\abs{q_{\y,z}-M_g^T\of{\cdot,(\y,z)}\cdot\p}=\abs{\eps -0}=\eps.$$}
\cref{eq:toshow} follows.
\end{proofof}

We next show that the protocol has perfect client-security. Consider an adversary $\adv$ corrupting the client. We construct the simulator $\Sim_{\adv}$ as follows.

\begin{enumerate}
	\item On input $\y\in\zo^m$ and auxiliary input $\aux\in\zo^*$, query $\adv$ to receive a message $\b^*$ to be sent to the OT. 
    
    \item Write $\b^*=(\b^*_1,\b^*_2)$, where $\b^*_1$ corresponds to the outputs and $\b^*_2$ corresponds to the watchlist.
    
    \item Apply the simulator guaranteed by the security of $\Pi_{\stb}$ to each pair of messages in $\b^*_1$ to obtain $\vect{b_{j}}_{j\in[m\cdot m']}$ for some $b_j\in\zo$, and apply the simulator $\Sim_{\ROT}$, guaranteed by $\Pi_{\rampOT}$ for each pair in $\b^*_2$ to obtain a set $\W\su[n]$.
    
    \item Send $\Dec\of{\vect{b_{j}}_{j\in[m\cdot m']}}$ to $\trustp$ to obtain an output $z$.
    
    \item Apply the PRE simulator on $z$ to obtain outputs $\vect{z_j}_{j\in[m\cdot m']}$ for each virtual client.
    
    \item If $|\W|>t$ then output $\vect{z_j}_{j\in[m\cdot m']}$ alongside whatever $\Sim_{\ROT}$ outputs and halt.
    
    \item Otherwise, apply the (semi-honest) MPC simulator on the parties $\set{\Sc_i}_{i\in\W}$ with random strings as inputs, and on $\set{\Cc_{j,b_j}}_{j\in[m\cdot m']}$ with $z_j$ as the output respectively. Send the output of the MPC simulator to $\Sim_{\ROT}$, outputs whatever it outputs and halt.
\end{enumerate}

\ifdefined\IsFV
The security of $\Pi_{\stb}$ and $\Pi_{\ROT}$ implies that $\vect{b_{j}}_{j\in[m\cdot m']}$ and $\W$ are distributed exactly the same in both worlds. Therefore, the output $z=g\of{x,\Dec\of{\vect{b_{j}}_{j\in[m\cdot m']}}}$ is distributed the same, hence applying the PRE simulator on $z$ will also result in the same distribution. Now, if $|\W|>t$ then $\Sim_{\ROT}$ is guaranteed to produce a correct view as an output. If $|\W|\leq t$, then the MPC simulator will generate $|\W|$ virtual views. Handing them over to $\Sim_{\ROT}$ would result in the view that is distributed the same as in the $\OThybrid$ world.
\else
It is easy to see that the by the perfect security of $\Pi_{\stb}$, $\Pi_{\ROT}$, the PRE, and the MPC protocol, that $\Sim_{\adv}$ is simulates $\adv$ perfectly.
\fi
\TODO{Decide if to keep explanation}
\end{proof}

\subsection{Proof of \texorpdfstring{\cref{thm:rampOT}}{Lemma 5}}\label{sec:missing}
We first prove the following simple claim, stating that the client will always reconstruct a unique secret (if its not outputting $\bot$).
\begin{claim}\label{clm:oneSecret}
Consider a message $\a^*=\vect{(a^*_{1,0},a^*_{1,1}),\ldots,(a^*_{n,0},a^*_{n,1})}\in\zo^{2sn}$ sent to the OT by a malicious server. Then for any different inputs $\y_1\ne\y_2$ for the client, either it will output $\bot$ for at least one of the inputs, or there exists a common secret $\myvec{r}$ that  will be reconstructed. 
\end{claim}
\begin{proof}
Let $\B=\set{i\in[n]:i\notin\y_1\wedge i\notin\y_2}$. Then $|\B|\geq n-t$, hence the client -- who receives the shares $\vect{a^*_{i,1}}_{i\in\B}$ -- can reconstruct a secret $\myvec{r}$ in case the share are consistent. This secret will be the same for both $\y_1$ and $\y_2$. 
\end{proof}

We now prove the lemma.

\begin{proofof}{\cref{thm:rampOT}}
By construction, it is not hard to see that the protocol is correct. We next prove that the protocol has perfect input-value security. Consider a adversary $\adv$ corrupting the server. We construct a simulator $\Sim_{\adv}$ as follows. On input $\x$ and auxiliary input $\aux\in\zo^*$, query $\adv$ to receive a message $\a^*=\vect{(a^*_{1,0},a^*_{1,1}),\ldots,(a^*_{n,0},a^*_{n,1})}\in\zo^{2sn}$. If there are no $n-t$ shares from $\vect{a^*_{i,1}}_{i\in[n]}$ that are consistent, then $\Sim_{\adv}$ will send the constant 1 predicate alongside some arbitrary input $\x_0$ to the trusted party $\trustp$. Otherwise, let $\B$ be the maximum set of indexes $i\in[n]$ such that the $a^*_{i,1}$ are shares consistent with single value $\myvec{r}\in\left(\zo^s\right)^n$. Then $\Sim_\adv$ will send to $\trustp$ the input $\left(\vect{a^*_{i,0}\xor r_i}_{i\notin\B},\vect{0^s}_{i\in\B}\right)$ with the predicate $P_\B(\y)=1$ if and only if $\y\cap\B\ne\emptyset$.

To see why the simulator works, observe that $\Sim_\adv$ sends constant 1 predicate if and only if $\adv$ sent at most $t$ consistent shares, forcing $\Cc$ to output $\bot$ in the ideal-world. Since this happens if there too many inconsistencies, $\Cc$ will output $\bot$ in the $\OThybrid$ world as well. Furthermore, if there are at least $n-t$ shares that are consistent, then by \cref{clm:oneSecret}, there is a unique secret $\myvec{r}$ that can be reconstructed. Therefore, in the $\OThybrid$ world, on input $\y$, $\Cc$ will output $\bot$ if $\y\cap\B\ne\emptyset$, and output $\vect{\a^*[\clnt_{\ROT}\of{\y}]_i\xor r_i}_{i\in\y}$ otherwise. Since $\B$ was chosen to be the maximum set of indexes, the same holds in the input-value ideal-world.

% As for perfect server security, we observe that for any $\a^*\in\zo^{2sn}$ sent to the OT, there exists a value $x^*\in\{0,1\}^{2ns}$ such that for every client's input $y$, 
% either $\bot$ or $x^*[y]$ is output (with probability 1), and the choice to abort or not depends on $y$. To see this, it suffices to observe the following

% \begin{observation}\label{obs-1}
% Fix some server strategy $s$. Then, for server strategy $s$, no two choices $c_1,c_2$ by the (honest) client yield corresponding reconstructed secret values $r_1\neq r_2$ that are both non-$\bot$. 	
% \end{observation}

% Assume the contrary, that for some server strategy $s=(s_{1,0},s_{1,1},\ldots,s_{n,0},s_{n,1})$ such $c_1,c_2$ exist.
% For any pair of sets $SR_1,SR_2$ of size $k_1$, $SR_1,SR_2$ have at least $n-k_1-k_1=n-2k_1$ coordinates in common. This set $B=SR_1\cap SR_2$ can thus reconstruct the secret $s$. To lead to non-$\bot$ output by $\Pi_R$, all reconstructing subsets of $SR_1,SR_2$ must agree with $s$ (if not, the corresponding output is $\bot$).


% Observation~\ref{obs-1} implies that all sets $SR$ leading to non-$\bot$ values for some $x$ lead to the reconstruction of the same value $r^*=s$ (if no such set exists, we fix $r^*$ arbitrarily). Therefor, $y^*=(s_{1,0}\oplus r^*_1,\ldots,s_{n,0}\oplus r^*_n)$ is as promised above. Now, clearly, for each $x$ $y^*[x]$ or $\bot$ is output (depending on the resulting $SR_x$). 

We next show that the relaxed security requirement against malicious clients holds. Let $\adv$ be an adversary corrupting the client. The simulator $\Sim_{\adv}$ works as follows. On input $\y$ and auxiliary input $\aux\in\zo^*$, query $\adv$ to receive $\b^*\in\zo^{n}$. If there are strictly more than $t$ 0's in $\b^*$ then output $n$ random strings, each of length $s$. Otherwise, send $\set{i\in[n]:b^*_i=0}$ to $\trustp$ to receive output $\vect{x_i}_{i:b^*_i=0}$. $\Sim_{\adv}$ samples $n$ random strings $r_1,\ldots,r_n\from\{0,1\}^s$. For $i\in[n]$, let $\myvec{r}[i]\in\zo^{sn}$ be a share of $\myvec{r}=(r_1,\ldots,r_n)$ in an $(n-t)$-out-of-$n$ Shamir's secret sharing (pad $\myvec{r}[i]$ if needed). The simulator then generates the values 
$$\a:=\Big(\vect{\srvr_{\stb}(x_i\xor r_i,\myvec{r}[i])}_{i:b^*_i=0},\vect{\srvr_{\stb}\of{0^{sn},\myvec{r}[i]}}_{i:b^*_i=1}\Big),$$
where the $x_i\xor r_i$'s are padded accordingly. $\Sim_\adv$ will then compute and output $$\bOT12^\ell\of{\a,\vect{\clnt_{\stb}\of{b^*_1},\ldots,\clnt_{\stb}\of{b^*_n}}}.$$

$\Sim_{\adv}$ works since in the case where there are more than $t$ 0's in $\b^*$, by the properties the sharing scheme, the view of $\Cc$ in the $\OThybrid$ world consist only of random values. Otherwise, $\Cc$ will receive the masked $x_i$ for the indexes $i$ on which $b^*_i=0$, and shares of the maskings for the indexes $i$ on which $b^*_i=1$.

% To see perfect server privacy holds, observe that if the client tries to learn a set $S$ of at most $k_2$ of the 0-inputs, it can also reconstruct the secret mask $r$, and recover all values in $S$.
% It learns nothing about the other values, as it only learns one out of 2 `shares' in an additive sharing of these values (originating form $r$), this can be simulated by sending $S$ in the ideal model.
% If it attempts to learn a set $S$ of size $>k_2$, it learns nothing about $r$, as it does not have enough shares of it, so that it learns nothing about any of the server's inputs (its view consists of random field elements for the Shamir sharing, and random strings for each of the server inputs in $S$). Thus, its input can be simulated given any $S$
% (let us fix some $S$ of size $k_1$) to be sent to the TP in the ideal model to simulate its view.
\end{proofof}

\deleted{
Let us recall and modify (a specific variant of) the original protocol $\Pi^{\epsilon}_{\text{IKOPS}}$ in more detail.
In particular, we change the watchlists from picking each server with
a certain probability $p$, to picking a random subset of size exactly $pn$. 

Here we represent  $X,Y,Z$ as some $X=\{0,1\}^{l_x},Y=\{0,1\}^{l_y},Z=\{0,1\}^{l_z}$. 
\begin{construction}[~\cite{IKOPS11}]\label{con-ikops+} 
	Fix $f$ as above, and a security parameter $\epsilon>0$. 
	Then $\Pi^+_{\text{IKOPS},f,\epsilon}$ is as follows.
	\begin{enumerate}	
	\item Let $\kappa=O(\epsilon^{-1})$ for a suitable constant to be determined later.
	 Let us encode input $x=(x_1,\ldots,x_{l_x})$ via
	$Enc_I(x)=(x_{1,1},\ldots,x_{1,\kappa+1},\ldots,x_{l_x,\kappa+1})$, where each $x_{i,1},\ldots,x_{i,\kappa+1}$ is a random additive sharing of $x_i$. Let $h:X^{\kappa+1}\times Y\rightarrow Z$ be defined as $h(Enc_I(x),y)=f((\oplus^{\kappa+1}_{i=1}x_{1,i},\ldots,\oplus^{\kappa+1}_{i=1}x_{\kappa+1,i}),y)$. 
	\item Let $(Enc_h,Dec_h)$ denote a decomposable PRE of a function $f'(x,y)$ related to $f$. For instance, we could separately encode each of the bits of $f(x,y)$ using the perfect formula-based encoding from~\cite{IK02}.
	The resulting encoding has monomials of degree at most 3, and degree 1 in $x,y$ or combinations of the form $x_iy_j$, but for a fixed value of $y$, all these become degree-1 in $x_i$ (with possibly $r_j$'s involved). Furthermore, each polynomial has a constant number of monomials, so it is easy to make the encoding (for any fixed $y$ decomposable by introducing a constant overhead and more randomness $r_s$~\cite{}). The complexity of this encoding is $(\kappa+|C|)^2$, where $|C|$ is the formula complexity of each bit of $f(x,y)$.
	\item Consider a semi-honest protocol $\Pi'$ for evaluating $f$ where $c=Enc_I(x)$, and the server inputs $s$ where $s_{i,b}=Enc_{h,i}(b,(y,r_s))$. The client then recovers $f(x,y)$ from
	$s[c]=s_{1,x_1},\ldots,s_{l_x,x_{l_x}}$ by applying $Dec_h$ to $s[c]$.
	We denote $\alpha=(\kappa+1)l_x$.%\footnote{We use $\alpha$ to be consistent with~\cite{} to help the reader who is familiar with~\cite{}.}
	\item To evaluate the protocol $\Pi'$ above, we reduce it to a COT (conditional OT) functionality, similar to that of~\cite{IKOPS11}. The COT protocol receives $(y,r)$ from the server, and evaluates the decomposable $NC_0$ encoding above to generate the $2l'_x$ purported output values 
	$(v_{1,0},v_{1,1},\ldots,v_{\alpha,0},v_{\alpha,1})=Enc_{h,1}(0,(y,r_s)),\ldots,Enc_{h,\alpha}(1,(y,r_s))$.   
	Each value is either the correct value $Enc_{h,i}(b,(y,r_s))$, or $\bot$ in case the $v_{i,b}$ is not consistent with $(y,r_s)$.
	As in~\cite{IKOPS11} the server performs MPC in the head 
	of an MPC protocol $\Pi_{HM}$ evaluating the COT functionality.
	The MPC participants are a sender with input $(y,r_s)$, $2\alpha$ clients and some $n$ virtual servers that perform the computation. The protocol proceeds by having the sender send messages to the virtual servers, the servers running $\Pi_{HM}$ among themselves, and sending the corresponding outputs to the clients during a single round at the end, where each client receives a single message from the virtual servers, from which it recovers its output.
s	
	The protocol has the following security guarantees.
	It is perfectly correct against any adversary corrupting
	the sender and at most $\delta n$ of the servers, and any number of the clients. Such protocols exist for all $\delta<1/3$.
	Also, we will $n$ to satisfy $2\lfloor \delta/3 n\rfloor < \lfloor \delta n\rfloor$ (from now on we omit $\lfloor\;\rfloor$ for brevity). Let us fix $\delta = 1/4$, which imposes that $n > 12$.
	
	If the sender is honest, $\Pi_{HM}$ is perfectly private against \emph{semi-honest} adversaries corrupting any subset of clients, and up to $\delta n$ of the virtual servers. 
	Consider~\cite{BGW88} as such a protocol with CC linear in the size of the encoding circuit, which is an optimized variant of~\cite{BGW88}.
	\item The server runs $\Pi'$ on $(y,r_s)$ in his head, generating the views $V_1,\ldots,V_n$ of the virtual servers, and the purported messages $V_{1,0},V_{1,1},\ldots,V_{2\alpha,1}$ received by each of the $2\alpha$ clients from all $n$ virtual parties.
	
	Recall that in~\cite{IKOPS11}, on input $x'=Enc(x)$, the parties run
	parallel instances of $\bOT{1}{2}{h}$ (for the proper value of $h$), where in the first $\alpha$ instances, instance $i$ inputs $V_{i,0},V_{i,1}$ are used by the server. 
	The other set of parallel OT's is dedicated to watchlists.
	The client picks $\delta/3 n$  of the views $V_1,\ldots,V_n$.
	This is done using the $\sOT{(\delta/3n ,\delta n)}{n}{h}$ protocol in $\Pi_{\text{ramp-OT}}$. 
	\footnote{As discussed above, the watchlist implementation is where we diverge from~\cite{IKOPS11}, everything so far is unmodified.}
	
	The client sends $c=(x_1,\ldots,x_\alpha)$ as its queries for the first part, we refer to as the ``keys'' part, and picks a random subset $S$ of size $\delta/3 n$ of $[n]$ as its input set for the watchlist part $\Pi_{ramp-OT}$.
	Given the replies of both parts: if $\Pi_{ramp-OT}$ outputs $\bot$, output $\bot$ as well. Otherwise, it reconstructs the set $\{V_{s\in S}\}_S$ of virtual server views.
	It checks whether all the recovered $V_i$'s are consistent among them (comparing messages sent and received among viewed parties, and that they are consistent with their inputs and randomness).
	The client outputs $\bot$ if an inconsistency among the watched views of the $V_i$'s was discovered. Otherwise, it checks whether any of the messages in some $V_{i,x_i}$ seen by the client are inconsistent with the values sent in the watched $V_j$'s. Otherwise, it reconstructs $f(x,y)=h(Enc(x),y)$ from $(V_{i,x_1},\ldots,V_{i,x_\alpha})$. 
	
	\end{enumerate}
\end{construction}	

\begin{lemma}\label{thm-pcl}
	Fix some $\epsilon>0$, and $f:X\times Y\rightarrow Z$. Then $\Pi^+_{\text{IKOPS},f,\epsilon}$ in
	Construction~\ref{con-ikops+} is perfectly correct for honest parties, and is perfectly server-private. It also satisfies enhanced $\epsilon$-client correctness. Let us denote the complexity of the resulting protocol by $\ell(\epsilon,|X|,|Y|)$.
	%The communication complexity of the construction is as follows. Let $h_i$ denote the smallest formula for evaluating the $i$'th bit of $f(x,y)$, and let $h = max_{i\leq \log(|Z|)} h_i$.
	%Then, $\Pi$ has communication complexity of 
\end{lemma}


%\begin{theorem}\label{thm-IVWD}[~\cite{}]
%	Let $f:X\times Y\rightarrow Z$ denote any (finite) function.
%	Then for all $\epsilon \geq 0$, there exists a protocol $\Pi$ evaluating $f$ with $\epsilon$-relaxed client correctness. 
%	Let $h_i$ denote the smallest formula for evaluating the $i$'th bit of $f(x,y)$, and let $h = max_{i\leq \log(|Z|)} h_i$.
%	Then, $\Pi$ has communication complexity of $l=\log(|Z|)\tilde{O}(\log(|X|) (\log({\epsilon^{-1}})+h)^2)$.
%\end{theorem}

\paragraph{Proof Sketch.} It easy to see that the protocol remains correct in face of honest parties. 
To prove  perfect server privacy, fix some client strategy $c^*$. The first part (virtual client views) of the protocol only discloses at most one $V_{i,b_i}$ for every $i\in[\alpha]$, by perfect server privacy of $\INT$. Let $x^*$ denote the input corresponding to the $b_i$'s learned (set $x^*_i$ arbitrarily).

We run the simulator guaranteed by $\Pi_{\text{ramp-OT}}$ of the malicious client strategy $c^*_2$ induced by $c^*$ on $\Pi_{ramp-OT}$. 
Consider the client's induced strategy in $\Pi_{\text{ramp-OT}}$. The simulator sends some distribution $M^*$ over $\{m\subseteq [n]||c|\leq \delta n\}$.
For $m^*$ in $support(H^*)$, by perfect server privacy of $\Pi_{HM}$, the client learns exactly what follows from $h(x^*,y)$, as it learns at most $\delta n$ of the virtual server's views. Like~\cite{IKOPS11}, we also use the fact that any value $v\in \{0,1\}^{\alpha}$ corresponds to $Enc_I(x)$ for some $x$, so client's view can be perfectly simulated given $Dec_I(x^*)$.

Enhanced $\epsilon$-client correctness holds similarly to the original construction. On a high level, the only new case that we need to address here is when $\Pi_{\text{ramp-OT}}$ makes the client output $\bot$.

In more detail, the simulator of the server acts as follows given the server's strategy $s^*$.
\begin{enumerate}
	\item It runs the simulator for $\Pi_{\text{ramp-OT}}$ on $s^*_2$, the part of the server's input corresponding to the wathlist part of the protocol.
	\item It picks a random  subset $T$ of size $\delta/3 n$ of $[n]$ Let $u_2$ denote the server's effective input guaranteed by $Sim_{\text{ramp-OT}}$ for client inputs $T$ for which the output is non-$\bot$. 
	\begin{enumerate}
	\item If the output is $\bot$ for all $T$, send $\bot$ as an input to the TP (of our two-party protocol evaluating $f$).
	\item Otherwise, let $u_2$ denote the extracted server's input guaranteed to exist by the security definition of $\Pi_{\text{ramp-OT}}$.
	Consider the consistency graph $G$' among the virtual servers induced by $u_2$, where an edge $(A,B)$ exists between a pair of virtual servers $A,B$ iff. their views do not match. That is, some message received by $B$ ($A$) does not match the message sent by $A$ ($B$) as determined by $A$'s ($B$) randomness and initial message from the sender.
	\begin{enumerate}
		\item If the minimal VC $L$ of the consistency graph $G'$ is of size $t>\delta/3 n$, send $\bot$ to the TP.
		\item Otherwise, $t<\delta/3 n$. Pick a subset $T$ of size $\delta/3 n$ among the virtual servers. If there is an edge of $G'$ inside $T$, send $\bot$ to the TP. Otherwise, let $u_1$ denote the sender's input extracted for the "keys" part of the protocol - executing the $\alpha$ parallel instances of $\INT$. 
		Complete the graph $G'$ into a graph $G$ with all virtual clients and virtual servers (but not the sender). Add edges between $V'$ and $V\setminus{V'}$ between client $A=(i,b)$ and server $B$ iff. $u_1[i,b]$ is not consistent with $B$'s message to $A$ according to $u_2$. 
		Let $B_1$ denote the set of client nodes that have a neighbor in $T$. Let $g=|B_1|$. If $g\geq \kappa+1$ or $x_{i,j,0},x_{i,j,1}\in B_1$ for some $i,j$ send $\bot$ to the TP. Otherwise, send the TP $\bot$ with probability $2^{-g}$, and $(y,r_s)$ otherwise (with probability $1-2^{-g}$). Here $(y,r_s)$ is obtained by extracting $(y,r_s)$ according to the views of the sender and $L$, as appearing in $u_2$. In particular, the sender's messages are taken from all virtual server's first messages as appearing in $u_2$. In particular, send $\bot$ if $(y,r_s)=\bot$ is extracted.
		\footnote{Here a note on simulator efficiency is in order. In this work we do not require efficient simulation. In particular, we compute exact minimal VC, rather than approximate VC, for the sake of simplicity. Similarly to~\cite{} we could have, had we strived for efficient simulation. The part of extracting $(y,r_s)$ is also efficient if $\Pi_{HM}$'s simulator is efficient. To be precise, the simulator is expected to receive the code of TM's rather than concrete views. The simulator assumes that the sender deterministically sends messages as in \emph{all} virtual server's views, and the virtual servers in $B$ have next-message functions consistent with the views in $u_2$, and arbitrary otherwise. As the protocol is $\Pi_{HM}$ perfectly correct in face of an adversary corrupting $\{sender\}\cup B$, the correct distribution $(y,r_s)$ is always extracted.}
		
		\end{enumerate}
	\end{enumerate}	
\end{enumerate}
 
It remains to prove that the simulator indeed satisfies the client correctness requirement. Consider several cases.
\begin{enumerate}
	\item Assume the server's input $s$ to the second part is such that the client outputs $\bot$ for all inputs $x\subseteq[n]$ of size $\delta/3 n$. Then the client in the real world outputs $\bot$ with probability 1. This is also the case in the simulation, leading to $\epsilon=0$ simulation error.
	\item Otherwise, let $u_2$ denote the server's input extracted by the simulator of $\Pi_{\text{ramp-OT}}$. This value is identical to the effective input in the real worlds (in fact, it is a single value, not even a general distribution).
	\begin{enumerate}
	\item If the inconsistency graph induced by $u_2$ is of size $t>\delta/3 n$, then the smallest  maximum matching in the graph is of size at least $t/2$. Thus, by a simple analysis using Chernoff bounds (see~\cite{} for details), the client picks a set $T$ of parties covering some edge in $G'$ with probability $2^{-\Theta(n)}$. Thus, with probability at least $1-2^{-\kappa}$, we the client outputs $\bot$. This probability may also rise due to an event of outputting $\bot$ for a certain choice of $T$ due to $\Pi_{\text{ramp-OT}}$ leading to an output of $\bot$ for that value of $T$. The simulator otuputs $\bot$ with probability $b_\bot=1$. Thus the security requirement is satisfied in this case for a proper choice of $\kappa$.  
	\item Otherwise, for fix some choice of $T$ by the client in the watchlist part. If $\bot$ is output due to $\Pi_{\text{ramp-OT}}$'s execution, then this is also the case when the simulator chooses $T$.
	Otherwise, extract  the server's effective input $\bot$ to the ``keys'' part of the protocol - it is also identically distributed to the effective input of the server to the first part (in fact, by structure of $\INT$, this is also a single value).
	Consider the set $B_1$ of nodes in $V\setminus{V'}$ with neighbors in $T$. 
	\begin{enumerate}
		\item\label{it-1} If $g\geq \kappa+1$, consider the maximal subset $B'_1\subseteq B_1$ where for every $\forall i\in[l_x],j\in[\kappa+1]\forall b\in\{0,1\}x_{i,j,b}\notin B'_1$. By the structure of $Enc_h$, at least a $(1-2\kappa^{-1})$-fraction of $B_1$ is in $B'_1$. This holds as for each $i$, we either keep all of the nodes in $B_1$, or remove at most $2$ out of at least $\kappa+1$. For all $x\in X$, the probability that $E_h(x)$ has some $x_{i,j}$ value so that node $x_{i,j,x_{i,j}}$ is in $B'_1$ is $1-2^{-|B'_1|}\geq 1-2^{-\kappa/2}$. In this case the client outputs $\bot$.
		The probability of outputting $\bot$ conditioned on choosing $T$ by the simulator is $1$. 
		\item Otherwise, $g\leq \kappa$. In this case, for all $x$, $B'_1=B_1$ (where $B_1,B'_1$ are defined as above). Therefore, for all $x$, the probability of outputting $\bot$ due to hitting an edge in $V\setminus{V'}\cup T$ is the same as for the simulator conditioned on choosing $T$. If the event of hitting an edge does not occur, the output induced by $u_2$ is always consistent with $(y,r_s)$ extracted by the simulator conditioned on picking $\bot$ (in particular, it may or may not equal $\bot$). 
\end{enumerate}
 	\end{enumerate}
\end{enumerate}

To summarize, for every input $x$, the extracted distribution on server inputs induces an output distribution that is at distance at most $2^{-\kappa}p_\bot$ from the real output distribution. More concretely, the difference stems only from case 2.b.ii.


\section{Applications}

As discussed in the intro, our protocol allows evaluating functions whose truth table are full-dimensional with computational (and communication) complexity which is independent of the security parameter to achieve 0 simulation error.
For domains that the not very large, this may help achieving concretely practical protocols. The focus of our work is mostly theoretical, so we did not try to optimize the concrete parameters, but it paves a way for designing protocols which may be competitive in efficiency (say, in CC) with the state of the art statistically or computationally secure protocols.

We observe that a large fraction of functions $f:X\times Y\rightarrow Z$ with $|Y|>|X|$ satisfy the requirements of Theorem~\ref{thm-main}. More concretely, analysis of row-rank of random functions with domains $|X|,|Y|,|Z|$ this fraction behaves
as $1-exp(-(|Y|-|X|(|Z|-1))$ (see discussion in~\cite{Ash14} for more details). For instance, at least $1-1.6\cdot 10^{-6}$ of the functions with $|Y|=31,|X|=30,|Z|=2$ can be computed with perfect security in the $\OThybrid$ model!

%Some useful functionalities that may computed with perfect security are some of $\sOT{k}{n}{h}$ satisfying ${n \choose k} (2^{kh}-1) < 2^{nh}$ (recall the restriction on size is only a necessary condition).
%One example of OT with small parameters for which we can verify the required condition is $\sOT{5}{2}{1}$. This leaves the cases of $\sOT{4}{2}{1}$ and $\sOT{3}{2}{1}$ open.
}

% \section{Our Analysis is Tight for Boolean Functions}\label{sec:limitation}
\section{Tightness of the Analysis for Boolean Functions}\label{sec:limitation}
Recall that our final protocol is a ``wrapper'' for an upgraded version of the protocol by \citet{IKOPS11}, namely, protocol $\Pi_{\IKOPS}^+$ from \cref{sec:up-ikops}. In the following section, we prove that for any \emph{Boolean} function $f$ that are \emph{not} full-dimensional, and do not satisfy the constraints in \cref{cor:main}, $\Pi_{\IKOPS}^+$ cannot be ``wrapped'' with a protocol that will compute $f$ with perfect full-security. Here, the ``wrapper'' protocol simply replaces the output $\bot$ that the client receive from $\Pi_{\IKOPS}^+$ with a random output. Formally, any ``wrapper'' protocol is parametrized with a vector $\v\in[0,1]^{|\Y|}$ and a small $\eps>0$, and we denote the protocol by $\Pi_f^{\v}\of{\eps}$. Let $g:(\X\cup\set{\bot})\times\Y\mapsto\set{\bot,0,1}$ be defined as $g(x,y)=f(x,y)$ if $x\ne\bot$ and $g(\bot,y)=\bot$. The ``wrapper'' protocol $\Pi_f^{\v}$ is described as follows.

% Recall that our protocol consists of $\Pi_f$ 
% as stated in the proof of \texorpdfstring{\cref{lem:geom}}{Lemma 2}, utilizing $\Pi_g = \Pi^+_{\IKOPS}\of{\eps}$~ as stated in Section~\ref{sec:up-ikops}.

% Technically, we consider the following generalized (template for) $\Pi_f$ suitable for general
% functionalities, thereby proving that a natural generalization of our approach does not work for
% non-full dimensional $f$'s.

\begin{protocol}[$\Pi_f^{\v}\of{\eps}$]\label{prot-gen-comb}~

Input: Server $\Sc$ has input $x\in\X$ and client $\Cc$ has input $y\in\Y$.

\begin{enumerate}
	\item The parties execute protocol $\Pi_{\IKOPS}^+\of{\eps}$ in order to compute $g$. Let $z$ be the output $\Cc$ receive.

	\item If $z\ne\bot$, then $\Cc$ output $z$. Otherwise, output 1 with probability $v_{y}$.
\end{enumerate}
\end{protocol}

\begin{theorem}
Let $f:\X \times \Y\mapsto \{0,1\}$ denote a (possibly randomized) Boolean function that has \emph{no} constant columns, \ie $M_f(\cdot,y)$ is not constant for every $y\in\Y$, and is \emph{not} full-dimensional, \ie $\operatorname{dim}\of{\aff{M_f^T}} < |\Y|$. \deleted{We assume $f$ is non-trivial, in the sense that $M_f$ does not contain constant columns.}\anote{It may be nicer in the sense of explaining where it comes from, to connect it to the section about $|X|=2$, and dominated columns. We can say that wlog. we can always remove columns that are dominated by other columns, rather than just constant columns - since we are in the malicious setting. This discussion belongs in that section about $|X|$, of course.
Not doing it for now to keep the explanation simple.}
Then for every $\v\in[0,1]^{|\Y|}$ and every $\eps>0$, $\Pi_{f}^{\v}\of{\eps}$ does not compute $f$ with perfect full-security.
\end{theorem}

\begin{proof}
Assume towards contradiction that $\Pi_f^{\v}\of{\eps}$ has perfect server security, for some $\v$ and $\eps$. We next construct $|\Y|+1$ adversaries, such that each adversary forces the vector of outputs of the client $\q^{\Pi_f^{\v}\of{\eps}}$, to be a different point inside the convex-hull of the rows of $M_f$. We then show that these points are affinely independent, giving us a contradiction. First, write each input of the client as a binary string $\y$ of length $m$. For every $\y\in\Y$ define the adversary $\adv_\y$ as follows.
\begin{enumerate}
\item Fix an encoding $\y'=\vect{y_j^1,\ldots,y_j^{m'}}_{j\in[m]}\in\Supp\of{\Enc(\y)}$, and fix some $x^*_{\y}\in\X$ such that $f(x^*_{\y},\y)\neq v_y$. (such an $x^*_{\y}$ exists, since $M_f$ does not have constant columns).
\item Execute $\Pi_{\IKOPS}^{+}\of{\eps}$ honestly with input $x^*_{\y}$, as fixed above, with the following one exception.
For every $i\in[n]$, $j\in[m]$, and $j'\in[m']$, modify $V^i_{m'(j-1)+j',1 - y^{j'}_j}$ such that it is inconsistent with $V_i$.
\end{enumerate}
Finally, define the adversary $\adv_0$ who picks an arbitrary $x^*_0\in\X$ as an input, and acts honestly with the exception that it tampers with all $V^i_{j,b}$'s, making them inconsistent with the corresponding $V_i$. Let $\a^*\of{x_{\y}^*}$ be the message $\adv_\y$ sends to the OT.

Let us analyze the client's vector of outputs $\q^{\Pi_f^{\v}\of{\eps}}\of{\a^*\of{x_{\y}^*}}$, for any adversaries $\adv_{\y}$, for $\y\in\Y\cup\set{0}$. For brevity, we write $\q\of{x^*_{\y}}$ instead. By definition, $\adv_0$ forces the client to sample its output according to $\v$, hence $\q\of{x^*_0}=\v$. Next, fix $\y\in\Y$. Observe that for every $\hat{\y}\neq\y$, any of their encodings will differ on at least one bit, \ie $\hat{y}_j^{j'}\neq y_j^{j'}$ for some $j\in[m]$ and $j'\in[m']$, hence on input $\hat{\y}$, the client will see $V^i_{m'(j-1)+j',1 - y^{j'}_j}$ for every $i$. Since the inconsistency is made with every virtual server, on input $\hat{\y}$, the client will notice it and output $\bot$ with probability 1. By the definition of $\Pi_f^{\v}$, it holds that 
\begin{align}\label{eq:othery}
q_{\hat{\y}}\of{x^*_{\y}}=v_{\hat{\y}},
\end{align}
for every $\hat{\y}\ne \y$. On the other hand, on input $\y$, the client outputs $\bot$ if and only if the event $\Enc\of{\y}=\y'$ occurs, which happens with probability $1-2^{-m(m'-1)}$. With the complement probability $2^{-m(m'-1)}$ it does not detect an inconsistency, and outputs $f(x^*_{\y},\y)$. Therefore
\begin{align}\label{eq:samey}
q_\y\of{x^*_{\y}}=2^{-m(m'-1)}\cdot f(x^*_{\y},\y)+(1-2^{-m(m'-1)})\cdot v_{\y}.
\end{align}

\ifdefined\IsFV
Let 
\begin{align}\label{eq:definedelta}
\delta_\y=2^{-m(m'-1)}(v_\y - f(x^*_\y,\y)).
\end{align}
Then \cref{eq:othery,eq:samey,eq:definedelta} imply that
\begin{align*}
\q\of{x^*_{\y}} = 
\v - \delta_{\y}\cdot\myvec{e}_\y,
\end{align*}
\else
Then \cref{eq:othery,eq:samey} imply that
\begin{align*}
\q\of{x^*_{\y}} = 
\v - 2^{-m(m'-1)}(v_\y - f(x^*_\y,\y))\cdot\myvec{e}_\y,
\end{align*}
\fi
where $\myvec{e}_\y$ is the $\y$-th unit vector in $\mathbb{R}^{|\Y|}$.

To conclude the proof, observe that $x^*_{\y}$ is such that $f(x^*_\y,\y)\ne v_\y$, \ifdefined\IsFV hence $\delta_{\y}\ne0$, \else\fi implying that the set of points $\set{\q\of{\x^*_{\y}}}_{\y\in\Y\cup\set{0}}$ are affinely independent. Furthermore, since $\Pi_f^{\v}$ is assumed to have perfect server security, \cref{lem:srvrsec} implies that all of theses points lie inside $\CH{M_f^T}$, hence the rows of $M_f$ span the entire space $\R^{|\Y|}$, contradicting the assumption that $f$ is not full-dimensional.
\end{proof}

%\paragraph{A perspective on the negative result.}
%We remark that other generalizations of our concrete protocol are not ruled out.
%We are inclined to believe that replacing $\Pi_g$ with some other protocol will not constitute for (non-trivial) functions which are not full-dimensional, but we are not able to prove this.
%A more promising approach seems to keep $\Pi_g$ an arbitrary (as long 

\subsection*{Acknowledgements}

We are very grateful to Yuval Ishai for suggesting this question, and for many helpful discussions. We also want to thank Eran Omri for many helpful comments.

\bibliographystyle{abbrvnat}
\bibliography{crypto}

\end{document}
