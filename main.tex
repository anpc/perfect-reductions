\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{complexity}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{enumitem}  
\setitemize{leftmargin=*, align=left}
 
%\usepackage{xcolor}
%\newcommand\todo[1]{\textcolor{red}{#1}}

\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}   
\newtheorem{claim}[theorem]{Claim}
\newtheorem{remark}{Remark}
\newtheorem{observation}{Observation}
\newtheorem{fact}{Fact}
\newtheorem{construction}{Construction}

\newcommand{\OT}[2]{#1\text{-out-of-}#2\text{-bit-OT}}
\newcommand{\TO}[2]{#1\text{-out-of-}#2\text{-bit-TO}}
\newcommand{\sOT}[3]{#1\text{-out-of-}#2\text{\;$#3$-string-OT}}
\newcommand{\support}{\mathrm{support}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\affine}[1]{\mathcal{A}(#1)}
\newcommand{\atodo}[1]{\textcolor{purple}{TODO: #1}}
\newcommand{\CH}[1]{\text{CH}(#1)}
\newcommand{\INT}{\Pi_{\text{int}}}

\title{On perfectly secure 2PC in the OT-hybrid model}
\author{Anat Paskin-Cherniavsky}

\begin{document}
\maketitle

\begin{abstract}
We initiate the study of perfect (rather than merely statistical) reductions among cryptographic primitives. For simplicity, we focus on finite functionalities.%\footnote{That is, protocol complexity is measureed only in terms of the security parameter $k$.}


While 1-out-of-2 bit-OT (and several other functionalities) is known to be complete for secure 2PC for all functionalities since the seminal work of Killian~\cite{Killian88}. This work only offers a statisticaly secure with abort (efficient) protocol in the OT-hybrid model (requiring no further computational assumptions). In general, fairness can not be guaranteed, and only security with abort is achievable~\cite{Cleve86}. If the protocol is not required to be efficient in the security paramter $k$, then all 2PC functionalities can be securely evaluated~\cite{GK10} with statistical security in the OT hybrid model.
As opposed to the statistical setting, it is not known whether OT is complete for perfectly secure 2PC. Furthermore, only a fewexamples of functionalities that have such reductions are known: we are only aware of string-OT~\cite{BCS96} and TO~\cite{WolfW06} (OT with reversed roles) as perfectly reducible to $\OT{1}{2}$.

On the negative side a large class is known, as implied by the fairness literature. By definition, functionalities not securely computable with fairness require super-polynomial in $k$ 
computational complexity to evaluate with error $neg(k)$ in the OT hybrid model (in fact, they are known to require super polynomial round complexity). 
This implies that these functionalities not computble with fairness are also not computable with perfect security (in the OT-hybrid model). For symmetric boolean functionalities, this class been fully characterized~\cite{}.

Back to the statistical world, quite surprisingly~\cite{IKOPS11} demonstrate that all client-server functionalities can be efficiently reduced to $\OT{1}{2}$ with statistical full security (no abort) in only \emph{one round}. Here a somewhat stronger oracle that securely evaluates ${\OT{1}{2}}^l$ (in particular, the client submits all inputs and recieves all outputs simultaneously) is assumed.%\atodo{Can we get rid of this assumption? Should verify later. Can I say it is a standard assumption in literature in the OT hybrid model ?}

This result demonstrates that for inefficient protocols, some functions require much higher round compliexty than others (in the OT hybrid model) than others to evaluate with statistical security In particular, client-server functionalities vs. symmetric coin tossing~\cite{Cleve86}.

Motivated by this relative ``ease'' of client-server functionalities for statisticaly secure 2PC in the OT hybrid model,
we start by studying perfect reductions to OT for this calss of functions. We prove that a large class of client-server functions is perfectly reducible to $\OT{1}{2}$.\footnote{Note that here the protocol is efficient by definition, as its complexity does not depend on the security parameter.}
 
We prove that for ``most'' client-server functions of the form $f:X\times Y\rightarrow \{0,1\}$, where server domain size $|Y|$ is larger than client domain size $X$, a $g(|X|,|Y|)=\Omega(1)$-fraction of functions are perfectly reducible to 1-out-of-2 OT. This fraction grows roughly as $1-exp(|X|-|Y|)$.
Furthermore, our reduction is 1-round using an oracle to secure evaluation of ${\OT{1}{2}}^l$. More generally, for $f:X\times Y\rightarrow Z$, $\Omega(1)$ of the functions with $|Y|>|X|(|Z|-1)$ are perfectly reducible to OT in 1 round. As an example, this class contains $\text{2-out-of-5-OT}$.

Our work leaves open the question of whether all finite client-server functionalities are reducible to bit-OT (not necessarily in one round). 
Another open question is whether 2PC functionalities that do have perfectly secure 
protocols in the OT hybrid model differ in round complexity, as is the case for statistical protocols.
 
In addition to the obvious theoretical appeal of the question towards better understanding secure computation, perfect, as opposed to statistical reductions may be useful for designing MPC protocols with high concrete efficiency, achieved by eliminating the dependence on a security parameter.
\end{abstract}

\section{Introduction}

We revisit the question of what are the simplest idealized functionalities required for perfect fully secure (without abort) 2PC. 
%Searching for the simplest possible setting, we focus on computationally unbounded parties.
As $\OT{1}{2}$ is complete for several useful security notions, in this work we focus on $\OT{1}{2}$ as a candidate. While the setting of statistical security is quite well understood, as we will soon see, the question of perfect security of 2PC in the OT hybrid model is almost entirely open. 

Briefly, in the OT-hybrid model, on addition to sending messages among themselves, the parties are allowed to make (any number of) calls to an idelized secure implementation of $\OT{1}{2}$. 
More precisely, we assume that in every round, one party either sends a message over the channel connecting the parties, or makes a call to an ideal OT functionality ${\OT{1}{2}}^l$ where $l\geq 1$
is some number. The same party plays the sender of the OT call.

That is, here we assume a somewhat stronger oracle that securely evaluates ${\OT{1}{2}}^l$, where $l$ may vary between rounds (in particular, the reciever submits all inputs and recieves all outputs simultaneously - he may not choose some of the inputs based on outputs of other OT calls).

Let us briefly review some key results on statistically and computationally secure protocols in the OT-hybrid model. %In this discussion we consider the more standard setting where protocols should be efficient, unless stated otherwise.
In this work, and when discussing efficient protocols from the literature, we focus on finite functionalities, so the complexity is measured in terms of a security parameter $1^k$ (where the simulation error is $\epsilon = neg(k)$).
 
\paragraph{Statistically secure 2PC in the OT-hybrid model.} Even inefficiently, statiscially secure computation is known to be impossible in the plain model even against semi-honest adversaries for some simple functions such as AND and OR~\cite{CK89}.
Here even a simulation error of, say, $1/3$ is not achievable.
Among the functionalities that are efficiently semi-honestly computable even with perfect security, some are not computable with statistical security against malicious parties in the plain model.

In particular, Cleve~\cite{Cleve86} has demonstrated that even the simple functionality of coin tossing where both parties output the same random bit, is not efficiently computable with statistical security. This impossibility extends to the OT-hybrid model.

As a consequence, the 2PC literature (more generally, MPC without honest majority) has settled on a weaker notion of security with abort where the ideal world adversary $A$ has the extra power allowing it to learn the output $f_A(x,y)$ first, and then decide whether to instruct the TP to send the honest party $B$ its output $f_B(x,y)$ or to send it $\bot$ (abort). General purpose 2PC protocols that are statistically secure with abort for any 2PC functionality have been developped starting with ~\cite{GMW91} in the computational setting, followed by~\cite{Killian88}, that only assumes an OT oracle (while~\cite{GMW91} relies on additional cryptographic primitives,\cite{Killian88} demonstrates how to implement these and many other cryptographic primitives using OT). 

A more recent alternative relaxation of statistical security~\cite{GK10}
allows for a polynomial error $poly(k^{-1})$, while requiring the parties are still efficient. In~\cite{GK10}, it is proved that all 2PC functionalities are computale with staistical security in the OT hybrid model according to this notion. They refer to this notion as $1/p$-security.

Furthermore, their results can be interpreted as staistically secure protocols in the OT hybrid model in our setting (when efficiency is not required).% These generalize previous constructions for coin tossing, that also satisfy this security notion.

Also, quite surprisingly, it turns out that many functionalities can be evaluated with statistical security by efficient protocols as discovered in the seminal work~\cite{GHKL08}, followed by works as~\cite{Ash14,ABMO15}. In particular,~\cite{ABMO15} completes the characterization of symmetric boolean functions
(where both parties recieve the same output)
 
However, all known protocols for such functions require round complexity of $\omega_k(1)$. In~\cite{IKOPS11}, a 1-round protocol is presented for client-server functionalities, where only the client learns an output. The protocol has a single round, and makes a single call to an  ${\OT{1}{2}}^l$ oracle (does not use the channel connecting the parties).
Furthermore, the protocol's computational and communication complexity are efficient in $k$. So, while all 2PC functionalities can be evaluated with statistical security in the OT hybrid model (possibly inefficiently), there are provable gaps in their round complexity. 

For instance, Cleve's impossibility result, and~\cite{GHKL08}'s result for functions with a so called \emph{embedded xor}, in fact prove that certain functionalities including coin-tossing require round complexity of $\omega_k(1)$. This puts, coin tossing much higher in the round complexity heirarchy than all client-server functionalities which have protocols with round complexity of 1.

\paragraph{Perfectly secure 2PC in the OT-hybrid model.}
While the statistical setting is qualitatively understood (for unbounded parties), and even the round complexity of protocols is partially understood, much less is known in the perfect setting. 
The ulitimate goal of this work is to understand which functionalities can be evaluataed with perfect security in the OT hybrid model.

On the positive side, we are aware of only a handful of perfect reductions to $\OT{1}{2}$. One is from string-OT~\cite{BCS96}, and one from $\TO{1}{2}$~\cite{WolfW06}, which is the same as $\OT{1}{2}$ where the roles of the parties are reversed. The first one sends no bits over the point to point channel, and only uses to ${\OT{1}{2}}^l$ oracle, while the latter only requires only a single bit of additional communication over the channel.
On the negative side, 2PC functionalities requiring $\omega_k(1)$ rounds mentioned above are not perfectly computable. 

Thus, the state of affairs is that most 2PC functionalities that are computable with fairness remain unclassified as to perfect security. 

\subsection{Our results}

Motivated by the relative ease of client-server functinalities for statistical security in the OT-hybrid model, we start with client-server functionalities.\\

\emph{Question 1. Characterize the set of 2PC functionalities (not necessarily boolean) which are perfectly secure in the OT-hybrid model.
As a starting point, can we characterize client-server functionalities ?}
 
We make progress on the above question, and discover a broad class of 2PC functionalities computable with perfect security.

\begin{theorem}[Informal]
	Let $f:X\times Y\rightarrow Z$ be a deterministic finite client-server functionality. If the trusth table of $f$ is full dimensional (as defined in~\cite{Ash14}), then $f$ is computable with perfect security in the OT-hybrid model.
\end{theorem}

We do not know whether all client-server functionalities are computable with perfect security, and leave it as an interesting open question.

In a nutshell, we start with a variant of~\cite{IKOPS11}'s protocol, which is statistically secure with abort. We rely on a special structure of the protcol, where the probability of $\bot$ is indpendent of the input, up to negligible differences.\footnote{In~\cite{IKOPS11},
they also put forward a protocol which is fully statistically secure, essentially by setting the server's input to some default value instead of outputting $\bot$. For the purpose of making the protocol perfectly seure, we make a different choice for $\bot$.}

To make the protocol perfectly secure against malicious clients, we modify the so called ``watchlists'' used in~\cite{IKOPS11}  to include exactly $k$ out of $n$ vritual servers, rather than enlist each server with a certain probability. Then, to make it perfectly secure against malicious servers, we rely on geometric interpretation of security (as previously used in the fairness literature), and come up with a way to replace $\bot$ in the ideal model simulating a corrupted server for functions of \emph{full dimension}.

\subsection{Future work - more on the relation to fairness}

Trivially, if a 2PC functionality has a perfectly secure protocols in the OT hybrid model it is also securely computable with fairness.
The other direction is not true. As follows from the $\omega_k(1)$ bound in~\cite{GHKL08} for symmetric functions with an embedded XOR, and the  construction of~\cite{Ash14} for all full dimensional functions (some of which have an embedded XOR), fairness does not imply perfect security. 

The work of~\cite{Ash14} puts forward a class of symmetric functions that have protocols which are statistically secure with fairness, for which our protocols do not work. The condition characterizing the functions that can be handled by his protocol is identical to ours. 

\begin{theorem}[Informal~\cite{Ash14}]
Every symmetric function $f(x,y)$ such that 	
the truth table $F$ of $f(x,y)$ is \emph{full-dimensional} (when considering the set of rows of the matrix representing $F$), can be evaluated with full security. 
\end{theorem}

This is precisely the condition we impose, where the columns of $F$ are labeled by $X$, and the rows are labeled by $Y$. However, if $F^T$
rather than $f$ is of full dimension, since $f$ is symmetric, reversing the roles of the row player and the column player allows to securely compute $f'(y,x)=f(x,y)$, and thus compute $f(x,y)$. 
For client-server functionalities, this transpose is not possible, as the roles of the parties in the protocol are not symmetric.

This is interesting, since client-server functionalities are particularly easy to implement with (statistical) fairness, while symmetric functionalities are less so. However, even symmetric functionalities that are computable with full statistical security may not be computable with perfect security even in their .

This provides guidence for candidate client-server functionalities  
with no perfect protocols to look at first.
\emph{Question 1.1.
Consider $f(x,y)$ for which $F$ is not full dimensional, but $F^T$ is.
Such functions have a protocol with full statistical security in the OT-hybrid model~\cite{Ash14}, but are not covered by our construction. Do all these function have a perfect protocol in the OT hybrid model? 
}

%Our result in particular implies that the subclass of .\footnote{In fact, our constructions satisfy the stronger standard defintion where efficient adversaries have an efficient simulator.}

Another interesting open question on perfect security is.\\ 

\emph{Question 2. For (inefficient) statistical security it follows from the fairness literature that increasing round complexity helps to evaluate more functions (some examples for efficient 2PC are also known: combining~\cite{Ash14,GHKL08} to obtain certain functions with embedded xor).
Does increasing round complexity beyond 1 allow to perfectly evluate more functions ? This relates to both client-server and other types of 2PC functionalities.} \\

One approach towards constructing such protocols (for general 2PC functionalities, not just client-server ones) is modifying~\cite{Ash14}'s GHKL-style protocols for general (possibly assymetric) functions. 

Here full dimension properties of $f$ alone will not generally suffice, as for (symmetric) functionalities with an embedded xor every protocol with error $neg(k)$ requires $\omega_k(1)$ rounds~\cite{GHKL08} so perfect security is in fact impossible.

\paragraph{Rodamap.} Section 2 includes some facts from geometry
and algebra that will be useful for us, and some useful facts on $\OT{1}{2}$. In this section we also present the concrete setting in which we work, which is essentially, the OT hybrid model with perfect security. The standard security definition is partially restated in geometric terms, which is crucial for the analysis of our main construction.
In section 3 we restate a folklore result as a simple instance of a perfect protocol in our model, which in fact, does not require an OT oracle at all. In section 4 we state our main perfect protocol working for so called \emph{full-dimensional} client-server functions.
In Section 5 we briefly go over possible applications of our result for concretely efficient 2PC constructions.

\paragraph{Aknowledgement.}

The author is very greatful to Yuval Ishai for suggesting this question, and for many helpful discussions. 

\section{Preliminaries}

\paragraph{Convex Geometry.} We will need the following geometric notion (eventually, the represent truth tables of 2PC functions).
\begin{definition}[Affine dimension~\cite{Ash14}]
	For a set of vectors $V=\{v_1,\ldots,v_t\}\subseteq\R^n$, we define their affine dimension $\affine{V}$ as the dimension of the set
	$\{v_i-v_1\}_{i\geq 2}$. 
\end{definition}
For a vector $v\in \R^m$, 
we let $|v|_1=\sum_i|v_i|$ denote its $\ell_1$ norm, and $|v|_\infty=max_i |v_i|$ denote its $\ell_\infty$ norm.
For a set of vectirs $V=\{v_1,\ldots,v_t\}\subseteq\R^n$, a linear combination $\sum_i \alpha_iv_i$ where $\sum_i\alpha_i=1$ and $\forall i\alpha_i\geq 0$ is a convex combination of $V$. The convex hall of $V$,
$\CH{V}=\{u=\sigma_i\alpha_iv_i|u\text{ is a convex combination of }V\}$.

\paragraph{Algebra.}

For a matrix $A\in \F^{n\times n}$, where $\F$ is a field, let
$|A|$ denote the determinant of $A$. $A^{i,j}$ denotes the $(i,j)$'th co factor of $A$, which is the $(n-1)\times(n-1)$ matrix obtained by removing the $i$'th row and $j$'th column of $A$.
It is well known that:
\begin{fact}\label{fact-cramer}
	$A^{-1}=C$ where $|C_{i,j}|=|A_{i,j}|/|A|$
	(Cramer's formula).
\end{fact}
For a pair of matrices $M_1\in \F^{n_1\times m},M_2\in \F^{n_2\times m}$, we denote by $[M_1||M_2]$ the concatenation of $M_2$ below $M_1$.

\paragraph{Oblivious Transfer (OT).}


The $\OT{1}{2}$ functionality is a client-server functionality, where the server inputs a pair $(b_1,b_2)$ of bits, the cleint inputs an index $i\in\{0,1\}$. The client outputs $b_i$, while the server outputs $\bot$.
A generalization $\OT{1}{t}$ of $\OT{1}{2}$ lets the client pick one out of $t$ bits $b_1,b_2,\ldots,b_t$ supplied by the server.
In a further generalization $\sOT{1}{t}{h}$ the $t$ bits are replaced by strings $s_1,\ldots,s_t\in \{0,1\}^h$, of which on input $i$ the client learns $s_i$.


A perfect reduction from $\sOT{1}{t}{h}$ to $\OT{1}{2}$ was put forward in the elegant work of~\cite{BCS96}, which constitutes one of the few examples of perfect reductions to $\OT{1}{2}$ known so far.

\begin{theorem}\label{thm-int}[\cite{BCS96}]
	There exists a perfectly secure protocol as in Definition~\ref{def-prot} of $\sOT{1}{2}{h}$ with communication complexity $l\leq (t-1)5h$. We refer to it as the $\INT$ protocol. 	
\end{theorem}
%For $\OT{k}{n}$ or $\sOT{k}{n}{h}$, it will be convenient to denote the input domain $X$ as $X=\{c\in\{0,1,\bot\}^n|c\text{ contains exactly }k\text{ non-}\bot\text{ values}\}$. 

\section{Our model}
We consider secure evaluation of client-server (non interactive, deterministic) functionalities $f:X\times Y\rightarrow Z$ for finite domains $X,Y,Z$, where the client outputs $f(x,y)$ and the server outputs $\bot$ (has no output).\footnote{All the definitions below readily generalize to radomized functionalities $f$, but we focus on deterministic $f$ for simplicity.} 
We focus on finite functionalities $f$ (that is $X,Y,Z$ are finite, and independent of a security parameters $k$).

We consider secure evaluation of such $f$ in the stand-alone setting, with unclonditional security, against a non adaptive malicious adversary corrupting a single party.
We work in an ``enhanced'' version of the OT-hybrid model where in every round a party either sends information over the point-to-point channel, or the parties make a call to a perfectly secure implementation of ${\OT{1}{2}}^l$ for some number $l$ that may depend on the round number (the client plays the reciever's role in all the oracle calls), which is rather standard. We assume the order of speaking is fixed, and does not depend on the communication so far, the inputs, or the randomness.
\footnote{The point-to-point channel is not necessary in 1-round protocols where the client does not send messages to the server, as any messages sent to the client over this channel can be emulated by the OT channel.} 
For client and server inputs $c\in\{0,1\}^l$, $s=((s_{1,1},s_{1,2}),\ldots,(s_{l,1},s_{l,1}))$ to ${\OT{1}{2}}^l$, respectively, we let $s[c]$ denote $s_{1,c_1},\ldots,s_{l,c_l}$.

Our security notion is the standard simulation-based notion as in~\cite{Can00}.
That is, we require statistical security against a malicious server or a malicious client, and perfect correctness if both parties behave honestly.
We say a protocol is $\epsilon(k)$-client correct if for any malicious server the simulation error is bounded from above by $\epsilon$.

More specifically, fix a 2PC protocol in the OT-hybrid model, where the parties are dubbed ``client'' and ``server'' respectively.
For any (non-uniform) adversary $A$ corrupting the server in $\Pi$, and $x\in X,z\in \{0,1\}^*$ define
$Real^{\Pi,z,x}_A=(OUT_A(1^k,z)(x),View_A(1^k,z)(z))$
For an ideal-world adversary $S$ controlling the server let 
$Ideal^{\Pi,z,x}_S=(OUT_S(1^k,z)(x),View_S(1^k,z)(z))$
We require that for any adversary $A$ there exists a simulator 
$S_A$ such that for all $x,z$ 
\[SD(Ideal^{\Pi,z,x}_S,Real^{\Pi,z,x}_A)=neg(k).\]
Here Ideal world adversary may not aborty the computation (that is, we require full security).
Additionally, if $A$ is polynomial-time, then so is $S_A$.
The definition for security against a corrupted client is analogous.

%	We consider standard efficient protocols with efficient simulation against PPT adversaries. The statistically (not perfectly) secure protocols we use as building blocks for our perfect constructions are in fact secure against unbounded adversaries with efficient simulation.
We say that the protocol is $\epsilon(k)$ server-private if the simulation error against every malicious client is bounded by $\epsilon(k)$.

For simplicity, we do not concern ourselves with the efficiency 
of protocols or the simulator, and allow all parties to be unbounded.
The adversaries we allow are also unbounded.
In fact, our simulator can be made efficient for efficient (in $k$) adversaries, but this is a secondary issue, and is deferred to the full version.

If the simulator's output joint with honest party's output
corresponding to (every) malicious adversary (server or client respectively) has distance $\leq \epsilon$ from the real world distributions, we say the protocol is statisticall $\epsilon$-secure. The protocol is statistically secure if $\epsilon(k)$ is negligible in $k$. If $\epsilon$ equals 0 for all adversaries, we say the protocol is perfectly secure against a malicious server (client).
%For simplicity, we deviate from the standard MPC model by removing the requirement of the parties and the simulator are efficient (in the security parameter).\footnote{This is only useful for non-perfect protocols, perfect protocols for finite functionalities as we consider are automatically efficient.} 

\paragraph{1-round protocols.}

In this work we further focus on 1-round protocols, where a single call to ${\OT{1}{2}}^l$ is made by the parties.
In this setting, security against malicious senders reduces to requiring that the 
client's output distribution alone is consistent with some input distribution $x^*$ over $X$, as the sender has no view and no output.
For corrupted clients, we again consider only their view alone, as the sender has no output. 
%\footnote{As we consider perfect protocols and finite functionalities, there is no issue of efficiently finding $x^*$.}

\begin{definition}[1-round protocols in OT-hybrid model]\label{def-prot}
	A protocol for evaluating $f:X\times Y\rightarrow Z$ are tuples $\Pi=(\Pi_Q,\Pi_R,\Pi_D)$ of randomized algorithms, where $\Pi_Q(x):X\rightarrow \{0,1\}^l$ generates client's query $c$. $\Pi_R(x,c,v):X\times\{0,1\}^l\times  \{0,1\}^l\rightarrow Z$ generates client's output based on $x,c$ and OT reply $v$.\footnote{For some, but not all functions $f$, $x$ is not required as an input to $R$, as $C_x\cup C_{x'}=\phi$ for all $x\neq x'$. It is not hard to prove that a sufficient condition on $f$ for having $C_x\cup C_{x'}=\phi$ in all secure protocols for $f$ is the existence of a $2\times 2$ rectangle $\{y,y'\}\times\{x,x'\}$ in which 3 of the entries are identical, and the other entry differs from these three.} $\Pi_D(y):Y\rightarrow \{0,1\}^{2l}$ is server's generator of OT inputs. We refer to $l$ as the communication complexity of $\Pi$.
\end{definition}

%For $s=(s_{1,0},s_{1,1},\ldots,s_{l,0},s_{l,1})\in\{0,1\}^{2l}$,
%and $c\in\{0,1\}^l$, we let $s[c]$ denote $(s_{1,c_1},\ldots,s_{l,c_l})$.
%For a vector $c\in \{0,1,\bot\}^l$ $s[c]$ is defined as above, but if $c_i=\bot$ the $i$'th entry in $s[c]$ equals $\bot$.


A protocl $\Pi=(\Pi_Q,\Pi_R,\Pi_D)$ as in Definition~\ref{def-prot} with CC $l$ operates in the ${\OT{1}{2}}^l$-hybrid model as described above.\footnote{In particular, it first recieves all inputs and only then returns all the outputs to the client. No rushing such as sending inputs to a certain OT instance after getting outputs from other OT instances is possible.}
That is, it is specified by a pair of randomized turing machines $\Pi^?_C,\Pi^?_S$ with oracle access to an idealized functionality ${\OT{1}{2}}^l$ operating as follows
\begin{enumerate}
	\item[$\Pi^?_C(x;r):$] 
	Let $c=\Pi_Q(x;r)$. Send $c$ as input to the ${\OT{1}{2}}^l$ oracle, and let $v$ denote the oracle's output. Output $\Pi_R(x,c,v;r)$.
	\item[$\Pi^?(y;r):$] Let $s=\Pi_D(y;r)$, and send it to the 
	${\OT{1}{2}}^l$ oracle.  
\end{enumerate}
Both algorithms $\Pi_C,\Pi_S$ run in parallel, in a single round.
We will usually use the notation $\Pi=(\Pi_Q,\Pi_R,\Pi_D)$ to denote protocols, while $\Pi_C,\Pi_S$ are implicit.

The above definition defines the syntax of protocols we consider. In the following (this and following section) we discuss the security requirements we pose on our protocols.

We will usually state our protocols in a hybrid model where the parties have access to some $l$ oracles $\sOT{1}{t_i}{h_i}$ in parallel, where $l$ and $(t_i,h_i)$ are numbers of our choice. 
This is potentially useful for optimizing the complexity of real-world, computationally secure protocols that are based on our construction, as OT extension allows to implement $\sOT{1}{2}{h}$ using a sublinear (in $k$) number of calls to $\OT{1}{2}$ and some additional sublinear work, assuming a strong variant of PRG~\cite{IKOS08}. 
Also, this is wlog. in our perfectly secure setting and costs only linear time $O(tk)$ to convert into a perfect protocol in the $\OT{1}{2}$-hybrid model by using the 1-round perfect reduction from Theorem~\ref{thm-int}.

From now on, all out definitions apply to 1-round protocols for client-server functionalities (in the OT hybrid), as we only consider this type of protocols. 

\begin{definition}\label{def-enh-cl}
Here, we assume that $f$ is defined on $f:X\times Y \rightarrow Z$,  where $\bot\in Y,Z$ and $f(x,y)=\bot$ iff. $x=\bot$.	
We say a protocol $\Pi$ as in Definition~\ref{def-prot} evaluates $f$ with  $\epsilon$-enhanced client correctness if it satisfies the same definition as $\epsilon$-client correctness, with the following additional guarantee.
For any (deterministic) server strategy $S^*$, there exists a distribution $Y^*$ over $Y$ such that for all $x$,
\[\Delta(\Pi_R(x,c\leftarrow \Pi_Q(x),S^*[c]), f(x,Y^*))\leq \epsilon p_{\bot}\] where $p_\bot=Pr_{Y^*}(\bot)$. \footnote{This enhances the $\epsilon$-client correctness requiring only a distance bound 
of $\epsilon$, rather than $\epsilon p_\bot$.} 
\end{definition}

The second notion is a relaxation of perfect client correctness.\footnote{This is a relaxation as it allows for conditional abort. It also strengthens the definition in the sense that every deterministic server strategy induces a single effective input $y$, rather than a distribution.}

\begin{definition}
Here we assume $\bot\in Y$.	
In the model with input-dependent client-security, we modify the ideal model to allow the simulator send a single value $y^*\in Y$ to the TP.	
It also gives the TP a predicate $P$ such that the TP sends the client $f(x,y)$ if $P(x)=0$, and $f(x,\bot)$ otherwise.	
We say a protocol $\Pi$ as in Definition~\ref{def-prot} evaluates $f$
with perfect input-dependent security, if for any adversary ,there exists a simulator with simulation error of 0.
\end{definition}

\subsubsection{Restating security requirements geometrically.}

We take a similar approach to that of~\cite{Ash14} 
to representing (some of the) protocols' security requirements geometrically.
%More specifically, we represent the client's output distributions vector for a given server's strategy as a vector over $\R^t$ for a suitable $t$. This vector bundles together client output dsitributions for all client's inputs, with a subset of coordinates corresponding to each client's input. A protocol $\Pi$ defines a region $P_S$ of achievable distributions corresponding to all possible (possibly malicious) server strategies.

%Similarly, for a given client's strategy, we consider the client's vector of \emph{views}, with a subset of coordinates corresponding to each server's input $y$.  Similarly to $P_S$, $\Pi$ defines a region $P_C$ of achievable distributions corresponding to all client's strategies. 

More specifically, for client correctness, we consider row distribution vectors achievable 
in the ideal model. That is, the region $\tilde{P}_S$ denotes all achievable row distributions corresponding to possible ideal-world server strategies.
This region simply corresponds to the convex hall of the rows of $f$'s 
truth table $F$.

%Jumping ahead, our representation of distributions will be such that the region $\tilde{P}_S$ will roughly correspond to convex combinations of row and column vectors of the function's truth table.

To achieve security against a malicious server, we require that
the region of real-world achievable row distributions $P_S$ satisfies
$P_S\subseteq \tilde{P}_S$.
Properties 2,3 in the security definition are verified directly.
%For honest correctness (that is, the protocol always outputs the correct value if both parties behave honesly), we make a separate requirement on distribution vectors corresponding to valid client and server strategies. %While the first two requirements are readily expressed as a single LP (linear program)~\cite{}, it is unclear how to incorporate the third requirement into the same program. 


\paragraph{Geometric representation of client's output distributions.}
Fix a protocol $\Pi=(\Pi_Q,\Pi_R,\Pi_D)$
as in Defition~\ref{def-prot} for evaluating a functionality $f:X\times Y\rightarrow Z$. For the sake of defining our output distributions we view the protocol as merely randomized mapping from $X\times Y$ to client outputs $Z$, and do not require it to securely evaluate $f$, or even correctly evaluate it if everyone behaves honestly.

\paragraph{Boolean functions.} Fix $Z=\{0,1\}$. For a given server's strategy $\Pi^*_D(x=y;r)=s^*$ for some fixed $s^*\in\{0,1\}^{2l}$\footnote{This notion naturally generalizes to randomized strategies, but we do not need this extent of generality here.}, 3we consider the distributions of the client's output at the end of a protocol execution $\Pi^*=(\Pi_Q,\Pi_R,\Pi^*_D)$ (that is, a protocol resulting from $\Pi$ when the server runs $\Pi^*_D$ instead of $\Pi_D$). We denote this set of distributions
by a vector $o\in \R^{|X|}$ indexed by $x\in [|X|]$. Here $o_x=p$ denotes the probability of the client outputting $1$ on input $x$
That is,
\[o_x = Pr_r[\Pi_Q(x;r)=c;\Pi_R(x,c,s^*[c])=1].\]

We refer to such a vector corresponding to some (possibly invalid) server's strategy $s^*$ as a \emph{geometric row distribution} for $\Pi$. 
We shall also consider geometric row distributions for the ideal model evaluating $f$, corresponding to server's input distributions $y\in Y$, referring to them as a row distribution for $f$. We ommit $\Pi,f$ whenever clear from the context.

Observe that the single number $o_x$ uniquely encodes a distribution over the client's output set $\{0,1\}$ on input $x$.\footnote{The vector $o$ represents $|X|$ separate distributions, one for each client's input $x$. Nothing is implied about the correlation between client's outputs on different inputs for a given server's strategy $s^*$.} Similarly, we consider \emph{geometric column distributions} for $\Pi$: for a given client's strategy $c^*\in\{0,1\}^l$ for its input to the OT oracle, we consider the corresponding \emph{geometric column} distribution vector $o\in \{0,1\}^{|Y|}$ indexed by  $y\in [|Y|]$, where $o_y$ is the probability of the client outputting $1$ for server input $y$. That is:
\[o_y = Pr_r[\Pi_R(x,c^*,\Pi_D(y;r)[c^*])=1].\]

\paragraph{General functions.} Generalizing for larger $Z=\{0,1,\ldots,k-1\}$, a (geometric) row distribution $o\in \mathbb{R}^{(k-1-1)|X|}$, has entries labeled by
pairs $(x,i)$ where $x\in [|X|],i\in Z\setminus{\{0\}}$, and $o_{(x,i)}$ denotes the probability of outputting $i$ on input $x$. Thus, for every $x,i$ we have $\sum_j o_{(x,j)}\leq 1$, and $o_{(x,i)}\geq 0$.\footnote{The decision to exclude 0 is merely auesthetic, intended to remain consistent with standard binary truth tables.}
As in the case of $|Z|=2$, this vector fully represents the client's output distribution for each input $x$. A similar extension can be made for (geometric) row distributions. For a given $x\in X$, let $o_x$ denote the sub-vector $(o_{x,z})_{z\in [k-1]}$.
%Also, the notion naturally extends to secure computation of randomized client-server functionalities $f:X\times Y\rightarrow Z$. Here exactly the same notions of client output distributions apply.

\paragraph{Truth tables.} In the truth table $F$ of $f$, we index rows by elements of $Y$ and columns by elements of $X$. For $Z=\{0,1\}$, the truth table representation we consider is just the standard one: a table where entry $(y,x)$ equals $f(x,y)$. We use $F_y$ to denote the row vector ($X_x$ to denote the column) in $F$ corresponding to $y$ ($x$).
We observe that each row $F_y$ in this case is a geometric row distribution in the ideal model, where the server inputs $y$. We can interpret $Y_{y,x}$ as $f(x,y) = p$, where $p$ is the probability of outputting $1$ (either $p=0$ or $p=1$). 


Let us generalize this form to larger $Z$. We represent the truth table in "unary", where for each $y,x$ we have $|Z|-1$ columns $(x,z)_{z\in [|Z|-1]}$, and we set $F((x,z),y)=1$
if $f(x,y)=z$, and $F((x,z),y)=0$ otherwise (if $f(x,y)=0$, all entires $F((x,z),y)$) will be $0$).\footnote{This is instead of having a single entry for each $(x,y)$ with values in $Z$.}
Again, each row $F_y$ is a valid geometric row distribution in the ideal world (corresponding to a server input of $y$).

\begin{definition}[~\cite{Ash14}]
	We say a function $f:X\times Y\rightarrow Z$ is full-dimensional if the affine dimension of the row set of its truth table $F$ is the maximal possible - $(|Z|-1)|X|$.
\end{definition}

\paragraph{Definition of security.}
As mentioned above, for client-server functionalities, the standard requirement of perfect stand-alone security in the ${\OT{1}{2}}^l$-hybrid model can be restated as three separate requirements, all involving only the client's output distribution.
%Let us recall the standard definitions of security against malicious parties in the ${\OT{1}{2}}^l$-hybrid model.
%\begin{definition}
%Let $\Pi$ denote a protocol for evaluating a function $f$ as in %Defintion~\ref{def-prot} in the ${\OT{1}{2}}^l$-hybrid model. Then it evaluates $f$ with malicoius security against a non adaptive malicious adversary if it satisfies:
%\begin{itemize}
%	\item[Security against malicious servers:]
%	For all algorithms $\Pi^*_D(y;r)$, there exists a randomized simulator algorithm $Sim^*_D(y;r):Y\rightarrow Y$ such that for all $x\in X,y\in Y,r_s$, the following equality of distributions holds.
%	\[\Pi_R(x,\Pi_Q(x;r_c),\Pi_D(y;r_s))=f(x,Sim^*_D(y;r_s))\]
%	\footnote{Wlog. we may assume $\Pi^*_D$ is deterministic. Also note that we do not require that the algorithms (as we generally consider finite functionalities). Due to the simple structure of $\Pi$ the above requirement can be further simplified to requiring that for all $.$ there exists a distribution $Y^*$ over $Y$ such that 
%	\[\Pi_R(x,\Pi_Q(x;r_c),s^*)=f(x,Y^*)\].}
%\end{itemize}
%\end{definition}
%\atodo{Is this defintion acceptable, or should I use the standard definition, with auxiliarry input $z$ and efficient simulation?}
For such functionalities and protocols $\Pi$ as in Definition~\ref{def-prot} the standard definition of perfect security against malicious parties is ``almost'' equivalent to the following definition.
It would be fully equivalent if it required simulation of efficient (in $k$) adversaries is also efficient. Our protocols in fact satisfy the stronger definition, as we prove in the full version. We ignore efficiency issues altogether in this work for the sake of simplicity. 

For simplicity, our security definition is stated without account for axuiliary information $z$ that the adversary and simulator recieve regarding the other party's input, required for sequential composition. It is easy to see that it in fact follows from our definition below. 

In our security definition, security against malicious servers is stated in geometrical terms, which will be useful for use later.
%In particular (in both direction), we take advantage of the fact that the server recieves no messages, and that the parties are unbounded, and consider only the client's view/output respectively. 

\begin{definition}[Perfect security of protocols as in Definition~\ref{def-prot}]\label{perfect-security}
We say that a protocol $\Pi$ as in Definition~\ref{def-prot} for evaluating a client-server functionality $f:X\times Y\rightarrow Z$ as above is perfectly secure against a single malicious party if it satisfies:
\begin{enumerate}
\item Client correctness: For every server's strategy $s^*\in \{0,1\}^{2l}$, the corresponding row distribution $o^*$ of $f'$
is in $\CH{\{F_y\}_{y\in Y}}$, where the $F_y$'s are the rows of the truth table $F$ of $f$.
\item Server privacy: For every client strategy $c^*$, there exists a simulator $S$ such that for all $y$,
$S(1^k)$ is distributed identically to $\Pi_D(y)$. 

\item Honest correctness: Let $C_x=\support(\Pi_Q(x)),S_y=\support(\Pi_D(y))$. Then for all $c\in C_x,s\in S_y$, $\Pi_R(x,c,s[c])=f(x,y)$.
\end{enumerate}
\end{definition}

Next we restate Definition~\ref{def-enh-cl} in geometrical terms.

\begin{observation}\label{obs-geom-enh-cl}
	Consider a protocol $\Pi$ evaluating a function $f$ as in Definition~\ref{def-enh-cl} with $\epsilon$-enhanced client correctness.
	Then the following holds. 
	For every server's strategy $s^*\in \{0,1\}^{2l}$, 
	there exists an ideal world row distribution $o^*\in \CH{\{F_y\}_{y\in Y}}$ such that 
	the real world row distribution $o'$ corresponding to $s^*$
	satisfies 
	\[\Delta(o',o^*)\leq \epsilon(|Z|-1)p_\bot\]
	Here $p_\bot$ is the coefficient of $Y_\bot$ in $o^*$.\footnote{This is not exactly equivalent to enhanced $\epsilon$-client correctness, as the parameters here are slightly worse, but this is all we need, and it simplifies the definition.}
\end{observation} 

\section{Warmup - $Y=\{0,1\}$}

As a warmup, we observe that for all finite $Z$
all client-server functions $f:X\times Y\rightarrow Z$ where $Y=\{0,1\}$
have a perfectly secure protocol in the OT hybrid model. In turn, this is a special case of a folklore construction for $f$'s where $F$ has a column $x_0$ that \emph{dominates} all other columns (recall that a column $x$ dominates a column $x'$ if for all $y\in Y$ $F(x,y)=F(x,y')$ implies that  $F(x',y)=F(x',y)$.). 
The protocol in fact does not use OT oracle, and is secure in the plain model.\footnote{The protocol is 1-round, and in particular can be replaced by one as in Definition~\ref{def-prot}, since sending a message in $|Z|$ over a channel can be implemented via a call to $\OT{1}{2}{\log{|Z|}}$ where the message to be sent is placed in both positions.}

This trivial (set of) examples is the only type of functions we know of that is not fully covered by our main construction~\ref{thm-main}. 

\begin{theorem}
	Let $f:X\times Y\rightarrow Z$ be a client server functionality where $F$ has a column $x_0$ that dominates all other columns. Then there exists a 1-round perfectly secure protocol for $f$ in the plain model.
\end{theorem}

\paragraph{Proof Sketch.} Consider the following protocol.
If all columns in $F$ are constant, the client just outputs $f(x_0,y_1)$ where $y_1\in Y$ is fixed arbitrarily without any communication. Otherwise, the server simply sends $o=f(x_0,y)$ to the client.
The client recovers $f(x,y)$ from $o$: as column $F^{x_0}$ dominates 
column $F^x$, $f(x,y)$ is uniquely determined by $o$.

The construction is private against malicious clients, as the client's view can be simulated by sending $x_0$ to the trusted party, where $x_0$ is an entry such that column $x_0$ in $F$ has two distinct entries.

A malicious server's behaviour can also be simulated, as it sends a message distributed over $\{f(x_0,y)\}_{y\in Y}$ according to some distribution (anything outside $Y$ is interpreted as some default value). \hspace*{385pt}$\blacksquare$ 


\begin{corollary}
	Let $f:X\times Y\rightarrow Z$ be a client server functionality where $Y=\{0,1\}$. Then there exists a 1-round perfectly secure protocol in the plain model.
\end{corollary}

%First observe that wlog. we may assume $Z=\{0,1\}$, as for each input $x$ we only need two labels for $f(x,y)$.\footnote{In general, we may assume $|Z|\leq |Y|$.}


\section{A perfect protocol where $F$ is full-dimesional}
Due to the simple structure of 1-round protocols in the OT hybrid model,
the first two security requirements are fully expressed as a single LP (linear program)~\cite{Kan39, Dantzig60} specifying $(\Pi_Q,\Pi_D,\Pi_R)$. However, it is unclear how to incorporate the third requirement into the same program. Thus, we do not write an explicit LP searching for a specification of $(\Pi_Q,\Pi_D,\Pi_R)$.
The resulting LP is not trivial to solve even for requirements 1,2 alone in~\ref{perfect-security}. 
Instead, we take a similar road to that used in the fairness literature, which considers protocols with more general structure. We suggest a concrete protocol, and prove it is secure for a certain subclass of functions. 

For every such function, we separately verify that each of conditions 1,2,3 in Definition~\ref{def-prot}.
As in the fairness literature, we do use techniques related to solving LP's (analyzing the convex hall of a certain point set) only for proving condition 1 is satisfied by our protocol, but not for searching for a protocol.

Our starting point is a protocol as in Definition~\ref{def-prot} (1-round protocol in the $(\OT{1}{2})^l$-hybrid model for some $l$) by~\cite{IKOPS11}[Section 3]. We denote this protocol by $\Pi_{\text{IKOPS}}$. It is stated for function with $NC_0$ circuits, but we restate it for general function (families), and bound its CC as a function of $|X|,|Y|,|Z|$ (which are assumed to be finite in our work). 

The reason the protocol in~\cite{IKOPS11} is restricted to $NC_0$ functionalities is for improving concrete efficiency, which is not a concern in our paper.
Otherwise, their construction works for all functions, as summarized below.

\begin{theorem}
	Let $f:X\times Y\rightarrow Z$ denote any (finite) client-server function.
	Then for all $\epsilon \geq 0$, $\Pi_{\text{IKOPS}}$ evaluates $f$ with $\epsilon$-relaxed client correctness. 
	Let $h_i$ denote the smallest formula for evaluating the $i$'th bit of $f(x,y)$, and let $h = max_{i\leq \log(|Z|)} h_i$.
	Then, $\Pi$ has communication complexity of $l=\log(|Z|)\tilde{O}(\log(|X|) (\log({\epsilon^{-1}})+h)^2)+polylog(\epsilon^{-1})$.
\end{theorem}

In a nutshell, in the $\Pi_{\text{IKOPS11}}$ protocol, reduces the evaluation of $f(x,y)$ to secure evaluation of a single instance of $l$ parallel instances of OT $\sOT{1}{2}{h}$ functionality for certain parameters $h,l$ depending on $f,\epsilon$. This is done using a decomposable randomized encodings of $f$~\cite{IK02}. Here we have $l=\log{|X|}$ - the input to $i$'th OT isntance is the bit $x_i$. 
The $y$ is mapped to a string seqeunce ${(s_{1,0},s_{1,1},\ldots,s_{l,0},s_{l,1})}$ fed to the OT's in a certain manner.

Now, to securely evaluate the resulting functionality in the malicious setting, the OT is replaced by a COT (certified OT) functionality. The COT returns the client the output, and additionally reports whether the resulting string is consistent with some $y$ and randomness $r$, as perscribed by reduction from $f(x,y)$ to the OT instances. 
$\Pi_{COT}$ verifyies that the OT input $s\in\{0,1\}^{2l}$ it feeds to the OT oracle is consistent with some $y,r$ for the reduction. 
Along with $s$, the server feeds a repressentation of $y,r$ as a witness that $s$ is consistent.
It gives client $C_i$ 
the OT output along with a bit on whether it is consistent (with that witness $y,r$ common for all indices) or not.

In the COT implementation, the server runs MPC in the head of an $n'$-party protocol $\Pi$ for evaluating the (randomized) mapping from a pair $(y,r)$ to a sequence $s$. More concretely, the protocol consists of a sender that privately sends $n$ virtual servers its inputs $y,r$, and some $2\log{h}$ clients that recieve corresponding OT outputs (the clients do not have inputs). There are also $2l$ clients have no inputs, but client $C_{i,b}$ gets the output of the $i$'th OT instance on input $x_i=b$. 
In $\Pi$, the virtual servers send messages to the clients in the last round of the protocol.

The COT client chooses the strings corresponding to the views seen by the virtual clients corresponding to its input $x$. Additionally, it asks for the entire view of the each of the virtual servers with some small constant probability $\delta'$. We observe that these so called \emph{watchlists} (the client watches only a small fraction of the virtual server), along with the requests for client's views can be perfectly reduced in oue round to $\OT{1}{2}$ oracles.


This MPC protocol $\Pi$ is secure against malicious corruption of $\delta n$ of the $n$ parties. With high probability, the client will see $p/2n < \delta' n<\delta n$ of the views, catching cheating with high probability, but not learning anyting besides $f(x,y)$.  
For a choice of $\delta'$ as above, the IKOPS protocol already happens to be statistically private against malicious clients.

There is however (small) non-zero probability of the client learning too much (in the worst case, $f(x,y)$ for all $x\in X$), by ending up watching too many of the virtual parties' view (potentially all of them). 

Thus, $\Pi_{IKOPS}$ is not perfectly server-private.
In the following section, we slightly tweak $\Pi_{IKOPS}$, making watchlists deterministic, thereby making it perfectly server-private. In Section~\cite{sec-serv-perf}, using geometric techniques, we demonstrate how to make the protocol from Section~\ref{sec-client-pr} perfectly client correct. Here we critically rely on the fact that $\Pi_{IKOPS}$ satisfies statistical enhanced client privacy, rather than just standard statistical client privacy. 

\subsection{Making $\Pi_{\text{IKOPS}}$ perfectly server-private}\label{sec-client-pr}

\subsubsection{Setting up deterministic watchlists}
Recall the problem with client privacy was in the fact that the client may watch the internal state of too make servers, breaching security of the protocol $\Pi$, and thus of the entire construction.
To solve this problem, we replace the probabilistic watchlist setup with a deterministic watchlist setup that allows the honest client to learn exactly $p_1n$ of the veiews of its choice, while no client can learn more than $p_2n$ of the values, where $p_2$ is not ``much larger'' than $p_1$. We also allow the server to input $\bot$, in which case the client should output $\bot$. Formally let $k_1,k_2,n,h$ where $n\geq k_2 > 2k_1$, and $h\geq 1$. We define $f_1:\sOT{k_1}{n}{h}$ and $f_2:\sOT{k_2}{n}{h}$. We extend the $f_i$ above into $f'_1:X'_1\times Y'_1\rightarrow Z'_1,f'_2:X'_2\times Y_2\rightarrow Z'_2$, so that $Z_i=Z_i\cup{\{\bot\}}$, $Y_i=Y_i\cup{\{\bot\}}$  so that $\forall x\in X_i,f_i(x,\bot)=\bot$.

\begin{theorem}[a $\sOT{(k_1,k_2)}{n}{h}$ protocol]
	There exists a protocol $\Pi$ as in Definition~\ref{def-prot} for $f'_1$ with communication complexity $l$. $\Pi$ satisfies:
	\begin{itemize}
	\item Perfect honest corretness.	
	\item Perfect client-correctness with input-dependent abort.
	\item Perfect server privacy relaxed to replace $f'_1$ with $f'_2$ (that is, malicious clients can be simulated by inputting additional, larger, sets beyond what is allowed by $f_1$).
	 \end{itemize} 
\end{theorem}

\paragraph{Proof.} We construct a protocol as required, we refer to as $\Pi_{\text{ramp-OT}}$.

\begin{construction}
	The parties perform $n$ $\sOT{1}{2}{nh}$'s in parallel (implemented via the ${\OT{1}{2}}^l$ using parallel instances of $\INT$).  
		\begin{enumerate} 
			\item $\mathbf{\Pi_D(y):}$ In the $i$'th instance the sender samples $n$ random strings $r_1,\ldots,r_n\in\{0,1\}^h$. Then, it secret-shares $r=(r_1,\ldots,r_n)$ with a $(n-2k_1)$-out-of-$n$ threshold using Shamir's secret sharing~\cite{Shamir79}. Let $s_1,\ldots,s_n\in \{0,1\}^{hn}$ denote the resulting shares. Output $s = (y_1\oplus r_1,s_1,y_2,s_2,\ldots,y_n\oplus r_n,s_n)$ (the $y_i$'s are padded accordingly).
			\item $\mathbf{\Pi_Q(x=\{x_1,\ldots,x_{k_1}\}):}$ Assume wlog. that all the $x_i$'s are distinct. Output $c=(c_1,\ldots,c_n)$, where $c_i=0$ iff. $i\in x = \{x_1,\ldots,x_{k_1}\}$.
			\item $\mathbf{\Pi_R(x,c,v=(v_1,\ldots,v_n)):}$ Here $v_i$ is the string returned by the $i$'th instance of $\INT$.
			Let $w_i = {\INT}_R(x,c_i,v_i)$ denote the output of the $i$'th instance of $\INT$. Use the $w_i$'s in $SR=[n]\setminus{x}$ to recover the secret vector $r$ as follows:
		\begin{enumerate}
		 \item If all subsets of size $n-2k_1$ of $SR$ agree on the same secret $r$, output $(w_i\oplus r_i)_{i\in x}$. 
		 \item Otherwise, output $\bot$.   
		\end{enumerate}
	\end{enumerate}
\end{construction}


We now prove the protocol satisfies the required security guarantees.
By consturction, it is not hard to see that the protocol satisfies honest correctness. As for client correctness, we observe that for any server strategy $r^*$ (input to OT oracle) there exists a value $y^*\in\{0,1\}^{2nh}$ such that for every client's input $x$, 
either $\bot$ or $y^*[x]$ is output (with probability 1), and the choice to abort or not depends on $x$. To see this, it sufficies to observe the following

\begin{observation}\label{obs-1}
Fix some server strategy $s$. Then, for server strategy $s$, no two choices $c_1,c_2$ by the (honest) client yield corresponding reconstructed secret values $r_1\neq r_2$ that are both non-$\bot$. 	
\end{observation}

Assume the contrary, that for some server strategy $s=(s_{1,0},s_{1,1},\ldots,s_{n,0},s_{n,1})$ such $c_1,c_2$ exist.
For any pair of sets $SR_1,SR_2$ of size $k_1$, $SR_1,SR_2$ have at least $n-k_1-k_1=n-2k_1$ coordinates in common. This set $B=SR_1\cap SR_2$ can thus reconstruct the secret $s$. To lead to non-$\bot$ output by $\Pi_R$, all reconstructing subsets of $SR_1,SR_2$ must agree with $s$ (if not, the corresponding output is $\bot$).


Observation~\ref{obs-1} implies that all sets $SR$ leading to non-$\bot$ values for some $x$ lead to the reconstruction of the same value $r^*=s$ (if no such set exists, we fix $r^*$ arbitrarily). Therefor, $y^*=(s_{1,0}\oplus r^*_1,\ldots,s_{n,0}\oplus r^*_n)$ is as promised above. Now, clearly, for each $x$ $y^*[x]$ or $\bot$ is output (depending on the resulting $SR_x$). To see perfect server privacy holds, observe that if the client tries to learn a set $S$ of at most $k_2$ of the 0-inputs, it can also reconstruct the secret mask $r$, and recover all values in $S$.
It learns nothing about the other values, as it only learns one out of 2 `shares' in an additive sharing of these values (originating form $r$), this can be simulated by sending $S$ in the ideal model.
If it attempts to learn a set $S$ of size $>k_2$, it learns nothing about $r$, as it does not have enough shares of it, so that it learns nothing about any of the server's inputs (its view consists of random field elemenets for the Shamir sharing, and random strings for each of the server inputs in $S$). Thus, its input can be simulated given any $S$
(let us fix some $S$ of size $k_1$) to be sent to the TP in the ideal model to simulate its view.

\subsubsection{Upgrading $\Pi_{\text{IKOPS}}$}

Let us recall and modify (a specific variant of) the original protocol $\Pi^{\epsilon}_{\text{IKOPS}}$ in more detail.
In particular, we change the watchlists from picking each server with
a certain probability $p$, to picking a random subset of size exactly $pn$. 

Here we represent  $X,Y,Z$ as some $X=\{0,1\}^{l_x},Y=\{0,1\}^{l_y},Z=\{0,1\}^{l_z}$. 
\begin{construction}[~\cite{IKOPS11}]\label{con-ikops+} 
	Fix $f$ as above, and a security parameter $\epsilon>0$. 
	Then $\Pi^+_{\text{IKOPS},f,\epsilon}$ is as follows.
	\begin{enumerate}	
	\item Let $\kappa=O(\epsilon^{-1})$ for a suitable constant to be determined later.
	 Let us encode input $x=(x_1,\ldots,x_{l_x})$ via
	$Enc_I(x)=(x_{1,1},\ldots,x_{1,\kappa+1},\ldots,x_{l_x,\kappa+1})$, where each $x_{i,1},\ldots,x_{i,\kappa+1}$ is a random additive sharing of $x_i$. Let $h:X^{\kappa+1}\times Y\rightarrow Z$ be defined as $h(Enc_I(x),y)=f((\oplus^{\kappa+1}_{i=1}x_{1,i},\ldots,\oplus^{\kappa+1}_{i=1}x_{\kappa+1,i}),y)$. 
	\item Let $(Enc_h,Dec_h)$ denote a decomposabe PRE of a function $f'(x,y)$ related to $f$. For instance, we could separately encode each of the bits of $f(x,y)$ using the perfect formula-based encoding from~\cite{IK02}.
	The resulting encoding has monomials of degree at most 3, and degree 1 in $x,y$ or combinations of the form $x_iy_j$, but for a fixed value of $y$, all these become degree-1 in $x_i$ (with possibly $r_j$'s involved). Furthermore, each polynomial has a constant number of monomials, so it is easy to make the encoding (for any fixed $y$ decomposable by introducing a constant overhead and more randomness $r_s$~\cite{}). The complexity of this encoding is $(\kappa+|C|)^2$, where $|C|$ is the formula complexity of each bit of $f(x,y)$.
	\item Consider a semi-honest protocol $\Pi'$ for evaluating $f$ where $c=Enc_I(x)$, and the server inputs $s$ where $s_{i,b}=Enc_{h,i}(b,(y,r_s))$. The client then recovers $f(x,y)$ from
	$s[c]=s_{1,x_1},\ldots,s_{l_x,x_{l_x}}$ by applying $Dec_h$ to $s[c]$.
	We denote $\alpha=(\kappa+1)l_x$.%\footnote{We use $\alpha$ to be consistent with~\cite{} to help the reader who is familiar with~\cite{}.}
	\item To evaluate the protocol $\Pi'$ above, we reduce it to a COT (conditional OT) functionality, similar to that of~\cite{IKOPS11}. The COT protocol recieves $(y,r)$ from the server, and evaluates the decomposable $NC_0$ encoding above to generate the $2l'_x$ purported output values 
	$(v_{1,0},v_{1,1},\ldots,v_{\alpha,0},v_{\alpha,1})=Enc_{h,1}(0,(y,r_s)),\ldots,Enc_{h,\alpha}(1,(y,r_s))$.   
	Each value is either the correct value $Enc_{h,i}(b,(y,r_s))$, or $\bot$ in case the $v_{i,b}$ is not consistent with $(y,r_s)$.
	As in~\cite{IKOPS11} the server performs MPC in the head 
	of an MPC protocol $\Pi_{HM}$ evaluating the COT functionality.
	The MPC participants are a sender with input $(y,r_s)$, $2\alpha$ clients and some $n$ virtual servers that perform the computation. The protocol proceeds by having the sender send messages to the virtual servers, the servers running $\Pi_{HM}$ among themselves, and sending the corresponding outputs to the clients during a single round at the end, where each client recieves a single message from the virtual servers, from which it recovers its output.
	
	The protocol has the following security guarantees.
	It is perfectly correct against any adversary corrupting
	the sender and at most $\delta n$ of the servers, and any number of the clients. Such protocols exist for all $\delta<1/3$.
	Also, we will $n$ to satisfy $2\lfloor \delta/3 n\rfloor < \lfloor \delta n\rfloor$ (from now on we omit $\lfloor\;\rfloor$ for brevity). Let us fix $\delta = 1/4$, which imposes that $n > 12$.
	
	If the sender is honest, $\Pi_{HM}$ is perfectly private against \emph{semi-honest} adversaries corrupting any subset of clients, and up to $\delta n$ of the virtual servers. 
	Consider~\cite{BGW88} as such a protocol with CC linear in the size of the encoding circuit, which is an optimized variant of~\cite{BGW88}.
	\item The server runs $\Pi'$ on $(y,r_s)$ in his head, generating the views $V_1,\ldots,V_n$ of the virtual servers, and the purported messages $V_{1,0},V_{1,1},\ldots,V_{2\alpha,1}$ recieved by each of the $2\alpha$ clients from all $n$ virtual parties.
	
	Recall that in~\cite{IKOPS11}, on input $x'=Enc(x)$, the parties run
	parallel instances of $\OT{1}{2}{h}$ (for the proper value of $h$), where in the first $\alpha$ instances, instance $i$ inputs $V_{i,0},V_{i,1}$ are used by the server. 
	The other set of parallel OT's is dedicated to watchlists.
	The client picks $\delta/3 n$  of the views $V_1,\ldots,V_n$.
	This is done using the $\sOT{(\delta/3n ,\delta n)}{n}{h}$ protocol in $\Pi_{\text{ramp-OT}}$. 
	\footnote{As discussed above, the watchlist implementation is where we diverge from~\cite{IKOPS11}, everything so far is unmodified.}
	
	The client sends $c=(x_1,\ldots,x_\alpha)$ as its queries for the first part, we refer to as the ``keys'' part, and picks a random subset $S$ of size $\delta/3 n$ of $[n]$ as its input set for the watchlist part $\Pi_{ramp-OT}$.
	Given the replies of both parts: if $\Pi_{ramp-OT}$ outputs $\bot$, output $\bot$ as well. Otherwise, it reconstructs the set $\{V_{s\in S}\}_S$ of virtual server views.
	It checks whether all the recovered $V_i$'s are consistent among them (comparing messages sent and recieved among viewed parties, and that they are consistent with their inputs and randomness).
	The client outputs $\bot$ if an inconsistentcy among the watched views of the $V_i$'s was discovered. Otherwise, it checks whether any of the messages in some $V_{i,x_i}$ seen by the client are inconsistent with the values sent in the watched $V_j$'s. Otherwise, it reconstructs $f(x,y)=h(Enc(x),y)$ from $(V_{i,x_1},\ldots,V_{i,x_\alpha})$. 
	
	\end{enumerate}
\end{construction}	

\begin{lemma}\label{thm-pcl}
	Fix some $\epsilon>0$, and $f:X\times Y\rightarrow Z$. Then $\Pi^+_{\text{IKOPS},f,\epsilon}$ in
	Construction~\ref{con-ikops+} is perfectly correct for honest parties, and is perfectly server-private. It also satisfies enhanced $\epsilon$-client correctness. Let us denote the complexity of the resulting protocol by $\ell(\epsilon,|X|,|Y|)$.
	%The communication complexity of the construction is as follows. Let $h_i$ denote the smallest formula for evaluating the $i$'th bit of $f(x,y)$, and let $h = max_{i\leq \log(|Z|)} h_i$.
	%Then, $\Pi$ has communication complexity of 
\end{lemma}


%\begin{theorem}\label{thm-IVWD}[~\cite{}]
%	Let $f:X\times Y\rightarrow Z$ denote any (finite) function.
%	Then for all $\epsilon \geq 0$, there exists a protocol $\Pi$ evaluating $f$ with $\epsilon$-relaxed client correctness. 
%	Let $h_i$ denote the smallest formula for evaluating the $i$'th bit of $f(x,y)$, and let $h = max_{i\leq \log(|Z|)} h_i$.
%	Then, $\Pi$ has communication complexity of $l=\log(|Z|)\tilde{O}(\log(|X|) (\log({\epsilon^{-1}})+h)^2)$.
%\end{theorem}

\paragraph{Proof Sketch.} It easy to see that the protocol remains correct in face of honest parties. 
To prove  perfect server privacy, fix some client strategy $c^*$. The first part (virtual client views) of the protocol only discloses at most one $V_{i,b_i}$ for every $i\in[\alpha]$, by perfect server privacy of $\INT$. Let $x^*$ denote the input corresponding to the $b_i$'s learned (set $x^*_i$ arbitrarily).

We run the simulator guaranteed by $\Pi_{\text{ramp-OT}}$ of the malicious client strategy $c^*_2$ induced by $c^*$ on $\Pi_{ramp-OT}$. 
Consider the client's induced strategy in $\Pi_{\text{ramp-OT}}$. The simulator sends some distribution $M^*$ over $\{m\subseteq [n]||c|\leq \delta n\}$.
For $m^*$ in $support(H^*)$, by perfect server privacy of $\Pi_{HM}$, the client learns exactly what follows from $h(x^*,y)$, as it learns at most $\delta n$ of the virtual server's views. Like~\cite{IKOPS11}, we also use the fact that any value $v\in \{0,1\}^{\alpha}$ corresponds to $Enc_I(x)$ for some $x$, so client's view can be perfecetly simulated given $Dec_I(x^*)$.

Enhanced $\epsilon$-client correctness holds similarly to the original construction. On a high level, the only new case that we need to adress here is when $\Pi_{\text{ramp-OT}}$ makes the client output $\bot$.

In more detail, the simulator of the server acts as follows given the server's strategy $s^*$.
\begin{enumerate}
	\item It runs the simulator for $\Pi_{\text{ramp-OT}}$ on $s^*_2$, the part of the server's input corresponding to the wishlist part of the protocol.
	\item It picks a random  subset $T$ of size $\delta/3 n$ of $[n]$ Let $u_2$ denote the server's effective input guaranteed by $Sim_{\text{ramp-OT}}$ for client inputs $T$ for which the output is non-$\bot$. 
	\begin{enumerate}
	\item If the output is $\bot$ for all $T$, send $\bot$ as an input to the TP (of our 2-party protocol evaluating $f$).
	\item Otherwise, let $u_2$ denote the extracted server's input guaranteed to exist by the security definition of $\Pi_{\text{ramp-OT}}$.
	Consider the consistency graph $G$' among the virtual servers induced by $u_2$, where an edge $(A,B)$ exists between a pair of virtual servers $A,B$ iff. their views do not match. That is, some message recieved by $B$ ($A$) does not match the message sent by $A$ ($B$) as determined by $A$'s ($B$) randomness and initial message from the sender.
	\begin{enumerate}
		\item If the minimal VC $L$ of the consistency graph $G'$ is of size $t>\delta/3 n$, send $\bot$ to the TP.
		\item Otherwise, $t<\delta/3 n$. Pick a subset $T$ of size $\delta/3 n$ among the virtual servers. If there is an edge of $G'$ inside $T$, send $\bot$ to the TP. Otherwise, let $u_1$ denote the sender's input extracted for the "keys" part of the protocol - executing the $\alpha$ parallel instances of $\INT$. 
		Complete the graph $G'$ into a graph $G$ with all vecrtual clients and virtual servers (but not the sender). Add edges between $V'$ and $V\setminus{V'}$ between client $A=(i,b)$ and server $B$ iff. $u_1[i,b]$ is not consistent with $B$'s message to $A$ according to $u_2$. 
		Let $B_1$ denote the set of client nodes that have a neighbor in $T$. Let $g=|B_1|$. If $g\geq \kappa+1$ or $x_{i,j,0},x_{i,j,1}\in B_1$ for some $i,j$ send $\bot$ to the TP. Otherwise, send the TP $\bot$ with probability $2^{-g}$, and $(y,r_s)$ otherwise (with probability $1-2^{-g}$). Here $(y,r_s)$ is obtained by extracting $(y,r_s)$ according to the views of the sender and $L$, as appearing in $u_2$. In particular, the sender's messages are taken from all virtual server's first messages as appearing in $u_2$. In particular, send $\bot$ if $(y,r_s)=\bot$ is extracted.
		\footnote{Here a note on simulator efficiency is in order. In this work we do not require efficient simulation. In particular, we compute exact minimal VC, rather than approximate VC, for the sake of simplicity. Similarly to~\cite{} we could have, if we strived for efficient simulation. The part of extracting $(y,r_s)$ is also efficient if $\Pi_{HM}$'s simulator is efficient. To be precise, the simulator is expected to recieve the code of TM's rather than concrete views. The simulator assumes that the sender deterministically sends messages as in \emph{all} virtual server's views, and the virtual servers in $B$ have next-message functions consistent with the views in $u_2$, and arbitrary otherwise. As the protocol is $\Pi_{HM}$ perfectly correct in face of an adversary corrupting $\{sender\}\cup B$, the correct distribution $(y,r_s)$ is always extracted.}
		
		\end{enumerate}
	\end{enumerate}	
\end{enumerate}
 
It remains to prove that the simulator indeed satisfies the client correcntness requirement. Consider several cases.
\begin{enumerate}
	\item Assume the server's input $s$ to the second part is such that the client outputs $\bot$ for all inputs $x\subseteq[n]$ of size $\delta/3 n$. Then the client in the real world outputs $\bot$ with probability 1. This is also the case in the simulation, leading to $\epsilon=0$ simulation error.
	\item Otherwise, let $u_2$ denote the server's input extracted by the simulator of $\Pi_{\text{ramp-OT}}$. This value is identical to the effective input in the real worls (in fact, it is a single value, not even a general distribution).
	\begin{enumerate}
	\item If the inconsistency graph induced by $u_2$ is of size $t>\delta/3 n$, then the smallest  maximum matching in the graph is of size at least $t/2$. Thus, by a simple analysis using Chernoff bounds (see~\cite{} for details), the client picks a set $T$ of parties covering some edge in $G'$ with probability $2^{-\Theta(n)}$. Thus, with probability at least $1-2^{-\kappa}$, we the client outputs $\bot$. This probability may also rise due to an event of outputting $\bot$ for a certain choice of $T$ due to $\Pi_{\text{ramp-OT}}$ leading to an output of $\bot$ for that value of $T$. The simulator otuputs $\bot$ with probability $b_\bot=1$. Thus the security requirement is satisfied in this case for a proper choice of $\kappa$.  
	\item Otherwise, for fix some choice of $T$ by the client in the wishlist part. If $\bot$ is output due to $\Pi_{\text{ramp-OT}}$'s execution, then this is also the case when the simulator chooses $T$.
	Otherwise, extract  the server's effective input $\bot$ to the ``keys'' part of the protocol - it is also identically distributed to the effective input of the server to the first part (in fact, by structure of $\INT$, this is also a single value).
	Consider the set $B_1$ of nodes in $V\setminus{V'}$ with nieghbours in $T$. 
	\begin{enumerate}
		\item\label{it-1} If $g\geq \kappa+1$, consider the maximal subset $B'_1\subseteq B_1$ where for every $\forall i\in[l_x],j\in[\kappa+1]\forall b\in\{0,1\}x_{i,j,b}\notin B'_1$. By the structure of $Enc_h$, at least a $(1-2\kappa^{-1})$-fraction of $B_1$ is in $B'_1$. This holds as for each $i$, we either keep all of the nodes in $B_1$, or remove at most $2$ out of at least $\kappa+1$. For all $x\in X$, the probability that $E_h(x)$ has some $x_{i,j}$ value so that node $x_{i,j,x_{i,j}}$ is in $B'_1$ is $1-2^{-|B'_1|}\geq 1-2^{-\kappa/2}$. In this case the client outputs $\bot$.
		The probability of outputting $\bot$ conditioned on choosing $T$ by the simualtor is $1$. 
		\item Otherwise, $g\leq \kappa$. In this case, for all $x$, $B'_1=B_1$ (where $B_1,B'_1$ are defined as above). Therefore, for all $x$, the probability of outputting $\bot$ due to hitting an edge in $V\setminus{V'}\cup T$ is the same as for the simulator conditioned on choosing $T$. If the event of hitting an edge does not occur, the output induced by $u_2$ is always consistent with $(y,r_s)$ extracted by the simulator conditioned on picking $\bot$ (in particular, it may or may not equal $\bot$). 
\end{enumerate}
 	\end{enumerate}
\end{enumerate}

To summarize, for every input $x$, the extracted distribution on server inputs induces an output distribution that is at distance at most $2^{-\kappa}p_\bot$ from the real output distribution. More concretely, the difference stems only from case 2.b.ii.\hspace*{240pt} $\blacksquare$


\subsection{Transforming $\Pi_{IKOPS^+}$ into a perfectly correct protocol}

In this section we describe the first step of the construction.
Here we rely on ideas from convex geometry that are somewhat similar to those of~\cite{Ash14}. In particular, the geometric interpretation of $\epsilon$-enhanced client correctness and the following notion of full-dimensional functions is central to our construction.


\begin{lemma}\label{lem-tt-perfect}
	Let $\epsilon>0$, and let $\Pi$ denote a protocol as in Definition~\ref{def-prot} for evaluating $f$ with $\epsilon$-enhanced client security, perfect server privacy, and perfect honest correctness. Then there exists a perfectly secure protocol as in Definition~\ref{def-prot} for evaluating $f$ with communication complexity $\ell(\epsilon,|X|,|Y|)$, where $\ell$ is as in Theorem~\ref{thm-pcl}. 
\end{lemma}

As a corollary from Lemma~\ref{lem-tt-perfect} and Theorem~\ref{thm-pcl}, we obtain our main result.

\begin{theorem}\label{thm-main}
Let $f:X\times Y\rightarrow Z$ denote a full-dimensional function, and
$g=|X|(|Z|-1)$.
Then there exists a protocol $\Pi'$ as in Definition~\ref{def-prot} evaluating $f$ with perfect security against a malicious adversary in the ${\OT{1}{2}}^l$-hybrid model
for $l=\ell(1/10(g-1)g!, |X|, |Z|)=\tilde{O}(h^2,poly(|X|,|Z|))$, where $\ell$ is the function in Theorem~\ref{thm-pcl}.
 
%$\log(|Z|)\tilde{O}(\log(|X|) (\log({\epsilon^{-1}})+h)^2)+polylog(\epsilon^{-1})=$

Here $poly(|X|,|Z|)$ is a global polynomial, independent of $f$.%\atodo{Calculate what the polynomial's degree is. The polylog factors are more tedious to compute.}

\end{theorem}

\paragraph{Proof sketch.}

We pick a sufficiently small $\epsilon>0$, to be set later, and consider $\Pi^+_{\text{IKOPS}^+,f,\epsilon}$. Fix some vector $v$ in the convex hall of $F$'s (not $F'$'s) rows $F_y$, which is ``far enough from the edges'' of that polygon.
By ``far enough'' we mean that adding up to $\pm\epsilon p_\bot$ in every coordinate
results in a point which is still inside the polygon.
Our protocol $\Pi'$ proceeds as follows. Whenever $\Pi^+_{\text{IKOPS}^+,f,\epsilon}$ outputs $\bot$ as an output on input $x$, output  a distribution consistent with $v_x$. Otherwise, output the value output by $\Pi$. 
Indeed, as $\Pi^+_{\text{IKOPS}^+,f,\epsilon}$ satisfies $\epsilon$-enchanced client correctness, its output distribution 
is of the form.
\begin{equation}\label{eq-1}
o^+ = \sum_i\alpha_i o_i + e_r
\end{equation}
Here $\alpha_i o_i$ is a convex combination of the rows $Y'_i$ of $F'$.
The vector $e_r$ is an error vector, $|e_r|_\infty\leq \epsilon\alpha_\bot$, where $\alpha_\bot$ is the coefficient of $Y_\bot$.\footnote{In fact, for every $x$, $|e_x|_1\leq \epsilon$ , but using this stronger property would not improve our result.}.

Now, as in $\Pi$, an output of $\bot$ on input $x$ is replaced by $v_x$,
$o^+$ in Equation~\ref{eq-1} is replaced by
\begin{equation}
\tilde{o} = \sum_{i\in Y}\alpha_i Y_i + \alpha_\bot (v_x+\tilde{e}_r)
\end{equation}

where $|e_r|_\infty\leq \epsilon$.
It remains to show that $d = v_x + \tilde{e}_r$ is in $\CH{\{Y_y\}_{y\in [|Y|-1]}}$ for the right choice of $v,\epsilon$. This is the case as if $d = \beta_i Y_i$ is a convex combination of $F$'s rows, we get that
\[\tilde{o} = \sum_{i\in Y}\alpha_i Y_i + \alpha_\bot (\beta_i Y_i)=\sum_{i\in Y}(\alpha_i +\alpha_\bot\beta_i)Y_i\]
Since $\alpha_1,\alpha_\bot,\ldots,\alpha_{|Y|}$, and (separately) the $\beta_i$'s are coefficients of a convex combination, thus constituting a valid ideal-world row distribution for $f$.

%Otherwise, the resulting row distribution vector $o_x$ in $\Pi$ is of the form $(1-\epsilon)v+e$, where $|e|_\infty\leq \epsilon$. 
%If $e_{x,\bot}=\alpha_{x,\bot}$, we add $\alpha_{x,\bot}v_x$ to $o'_x$,
%the row distribution vector in $\Pi'$.
%Thus, $o'_x$ is a (syntactically) valid distribution for $f$ \[(1-\epsilon)v+e'\] where $|e'_x|_1\leq \epsilon$ for all $x$ (by a simple calculation, that stems from the fact that $F$ has 0/1 entries, and $v$ has entries in $[0,1]$). In particular, $|e'|_\infty\leq \epsilon$ as well, leaving us inside the convex hall of the $Y_i$'s for sufficiently small $\epsilon$ (since $f$ is full rank). 

It remains to prove that there is a way to pick $v,\epsilon$ 
so that the resulting $\tilde{o}$ satisfies the client correctness requirement.
Since $f$ is full-rank, let us pick  a set of size $g=|X|(|Z|-1)+1$ of rows of $F$, $V = \{Y_1,\ldots,Y_g\}$, such that the dimension of $\{\Delta_{i-1} = Y_i - Y_1\}_{i\geq 2}$ is $g-1$. We will pick $v$ as a convex combination
\[\sum_{i\leq g}\alpha_iY_i\]
of the $Y_i$'s, which we determine in the following.
As $F$ has 0-1 entries we have 
\begin{observation}\label{obs-1}
Each $\Delta_j$ is has entires in the set $\{0,1,-1\}$.
\end{observation}
Let us pick
\[v = 3/4Y_1 + \sum_{2\leq i\leq g}1/4(g-1) Y_i\]

Now, we adapt $\epsilon$ to this choice based on the following observation.
\begin{claim}\label{clm-proj}
Let $u\in \R^{g-1}$ be a vector with $|u|_\infty \leq \epsilon$. 
Then, in the representation $u = \sum_{i\leq g-1}\alpha_i\Delta_i$
(it exists and is unique as the $\Delta_i$'s form a basis of $\R^{g-1})$),
it must be the case that $|\alpha_i|\leq \epsilon \cdot g!$.  
\end{claim}

To prove the claim we apply Fact~\ref{fact-cramer} to $M=(\Delta_1||\Delta_2||\ldots \Delta_{g-1})$, and use Observation~\ref{obs-1} to bound each $|{M}^{-1}_{i,j}|$ as $|C_{i,j}|\leq (g-1)!/1=(g-1)!$. Now, the solution to $Mx=u$ is $M^{-1}u$, thus we get $|x|_\infty\leq (g-1)(g-1)!\epsilon\leq g!\epsilon$, as required (here $g-1$ is the length of $u$).

We can rewrite a convex combination of the $Y_i$'s as
\begin{equation}\label{eq-1}
\sum_{i\leq g}\alpha_iY_i=Y_1+\sum_{i\leq g-1}\alpha_{i+1} \Delta_i
\end{equation}
where the $\alpha_i$'s on the right hand side are non-negative integers summing to \emph{at most} $1$ (and move back and forth between the two representations). In particular, we have
\[v = Y_1+1/4(g-1)\sum_{i\leq g-1}\Delta_i\]
Recall also that the resulting row distribution is
$o'=(1-\epsilon)v + e'$, where $|e'|_\infty\leq \epsilon$.
Thus, we have $e'=\sum_{i\leq g-1}\alpha_i\Delta_i$, where $|\alpha_i|\leq g!\epsilon$. 

Thus, we have
\[o'=(1-\epsilon)v+e'=Y_1+(1-\epsilon)1/g\sum_{i\leq g-1}\Delta_i+(e'-\epsilon Y_1)\]
Let us write $w=e'-\epsilon Y_1$. Clearly, $|w|_\infty\leq 2\epsilon$.
Here $|\beta_i|\leq 2\epsilon$ for each $i$.
Thus, from Claim~\ref{clm-proj} we have
\[o'= Y_1+\sum_{i\leq g-1}((1-\epsilon)1/4(g-1)+\beta_i)\Delta_i\]

where $|\beta_i|\leq 2g!\epsilon$. Thus (since $g\geq 2$), picking $\epsilon=1/10(g-1)(g!)$, we obtain $o'$ of the form presented in Equation~\ref{eq-1}, which falls in the required region (the coefficients of the $\Delta_i$'s are all non-negative and sum to at most $1$). 


\section{Applications}

As discussed in the intro, our protocol allows evaluating functions whose truth table are full-dimensional with computaitonal (and communication) complexity which is independent of the security parameter to achieve 0 simulation error.
For domains that the not very large, this may help achieving concretely practical protocols. The focus of our work is mostly theoretical, so we did not try to optimize the concrete parameters, but it paves a way for designing protocols which may be competitive in efficiency (say, in CC) with the state of the art statisticaly or computationally secure protocols.

We observe that a large fraction of functions $f:X\times Y\rightarrow Z$ with $|Y|>|X|$ satisfy the requirements of Theorem~\ref{thm-main}. More concretely, analysis of row-rank of random functions with domains $|X|,|Y|,|Z|$ this fraction behaves
as $1-exp(-(|Y|-|X|(|Z|-1))$ (see discussion in~\cite{Ah14} for more details). For instance, at least $1-1.6\cdot 10^{-6}$ of the functions with $|Y|=31,|X|=30,|Z|=2$ can be computed with perfect security in the OT-hybrid model!

Some useful functionalities that may computed with perfect security are some of $\sOT{k}{n}{h}$ satisfying ${n \choose k} (2^{kh}-1) < 2^{nh}$ (recall the restriction on size is only a necessary condition).
One example of OT with small parameters for which we can verify the requied condition is $\sOT{5}{2}{1}$. This leaves the cases of $\sOT{4}{2}{1}$ and $\sOT{3}{2}{1}$ open.


\bibliographystyle{unsrt}
\bibliography{sample}

\end{document}
